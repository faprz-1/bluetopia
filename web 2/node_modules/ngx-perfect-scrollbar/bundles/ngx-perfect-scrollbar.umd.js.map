{"version":3,"file":"ngx-perfect-scrollbar.umd.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 52f63939808a910c2704","webpack:///external \"@angular/core\"","webpack:///./src/lib/perfect-scrollbar.interfaces.ts","webpack:///./src/lib/perfect-scrollbar.directive.ts","webpack:///./src/lib/perfect-scrollbar.component.ts","webpack:///./src/index.ts","webpack:///./node_modules/rxjs/add/operator/throttleTime.js","webpack:///./node_modules/rxjs/add/operator/distinctUntilChanged.js","webpack:///./node_modules/rxjs/Subject.js","webpack:///./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","webpack:///./src/lib/perfect-scrollbar.component.html","webpack:///./src/lib/perfect-scrollbar.component.scss","webpack:///./src/lib/perfect-scrollbar.module.ts","webpack:///external \"@angular/common\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@angular/core\"), require(\"@angular/common\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ngx-perfect-scrollbar\", [\"@angular/core\", \"@angular/common\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngx-perfect-scrollbar\"] = factory(require(\"@angular/core\"), require(\"@angular/common\"));\n\telse\n\t\troot[\"ngx-perfect-scrollbar\"] = factory(root[\"@angular/core\"], root[\"@angular/common\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_13__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 52f63939808a910c2704","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@angular/core\"\n// module id = 0\n// module chunks = 0 1","export class Geometry {\n  public x: number;\n  public y: number;\n\n  public w: number;\n  public h: number;\n\n  constructor(x: number, y: number, w: number, h: number) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n}\n\nexport class Position {\n  public x: number | 'start' | 'end';\n  public y: number | 'start' | 'end';\n\n  constructor(x: number | 'start' | 'end', y: number | 'start' | 'end') {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nexport const PerfectScrollbarEvents = [\n  'ps-scroll-y',\n  'ps-scroll-x',\n\n  'ps-scroll-up',\n  'ps-scroll-down',\n  'ps-scroll-left',\n  'ps-scroll-right',\n\n  'ps-y-reach-end',\n  'ps-y-reach-start',\n  'ps-x-reach-end',\n  'ps-x-reach-start'\n];\n\nexport interface PerfectScrollbarConfigInterface {\n  handlers?: string[];\n\n  wheelSpeed?: number;\n  swipeEasing?: boolean;\n\n  suppressScrollX?: boolean;\n  suppressScrollY?: boolean;\n\n  useBothWheelAxes?: boolean;\n\n  wheelPropagation?: boolean;\n  swipePropagation?: boolean;\n\n  scrollingThreshold?: number;\n\n  minScrollbarLength?: number;\n  maxScrollbarLength?: number;\n\n  scrollXMarginOffset?: number;\n  scrollYMarginOffset?: number;\n}\n\nexport class PerfectScrollbarConfig implements PerfectScrollbarConfigInterface {\n  public handlers: string[];\n\n  public wheelSpeed: number;\n  public swipeEasing: boolean;\n\n  public suppressScrollX: boolean;\n  public suppressScrollY: boolean;\n\n  public useBothWheelAxes: boolean;\n\n  public wheelPropagation: boolean;\n  public swipePropagation: boolean;\n\n  public scrollingThreshold: number;\n\n  public minScrollbarLength: number;\n  public maxScrollbarLength: number;\n\n  public scrollXMarginOffset: number;\n  public scrollYMarginOffset: number;\n\n  constructor(config: PerfectScrollbarConfigInterface = {}) {\n    this.assign(config);\n  }\n\n  public assign(config: PerfectScrollbarConfigInterface = {}) {\n    for (const key in config) {\n      this[key] = config[key];\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./src/lib/perfect-scrollbar.interfaces.ts","import PerfectScrollbar from 'perfect-scrollbar';\n\nimport ResizeObserver from 'resize-observer-polyfill';\n\nimport { SimpleChanges, KeyValueDiffers } from '@angular/core';\nimport { NgZone, Directive, Optional, ElementRef } from '@angular/core';\nimport { OnDestroy, DoCheck, OnChanges, AfterViewInit } from '@angular/core';\nimport { Input, Output, EventEmitter, HostBinding, HostListener } from '@angular/core';\n\nimport { Geometry, Position } from './perfect-scrollbar.interfaces';\n\nimport { PerfectScrollbarConfig, PerfectScrollbarConfigInterface } from './perfect-scrollbar.interfaces';\n\n@Directive({\n  selector: '[perfect-scrollbar], [perfectScrollbar]',\n  exportAs: 'ngxPerfectScrollbar'\n})\nexport class PerfectScrollbarDirective implements OnDestroy, DoCheck, OnChanges, AfterViewInit {\n  private ps: any;\n  private ro: any;\n\n  private timeout: number;\n\n  private configDiff: any;\n\n  @Input() fxShow: boolean = true;\n  @Input() fxHide: boolean = false;\n\n  @Input() hidden: boolean = false;\n\n  @Input() disabled: boolean = false;\n\n  @HostBinding('class.ps')\n  @Input() usePSClass: boolean = true;\n\n  @HostBinding('style.position')\n  @Input() psPosStyle: string = 'relative';\n\n  @Input() runInsideAngular: boolean = false;\n\n  @Input('perfectScrollbar') config: PerfectScrollbarConfigInterface;\n\n  @Input('perfect-scrollbar')\n  set oldConfig(config: PerfectScrollbarConfigInterface) {\n    console.warn('Deprecated use of perfect-scrollbar selector, use perfectScrollbar instead!');\n\n    this.config = config;\n  }\n\n  @Output('psScrollY'        ) PS_SCROLL_Y            = new EventEmitter<any>();\n  @Output('psScrollX'        ) PS_SCROLL_X            = new EventEmitter<any>();\n\n  @Output('psScrollUp'       ) PS_SCROLL_UP           = new EventEmitter<any>();\n  @Output('psScrollDown'     ) PS_SCROLL_DOWN         = new EventEmitter<any>();\n  @Output('psScrollLeft'     ) PS_SCROLL_LEFT         = new EventEmitter<any>();\n  @Output('psScrollRight'    ) PS_SCROLL_RIGHT        = new EventEmitter<any>();\n\n  @Output('psYReachEnd'      ) PS_Y_REACH_END         = new EventEmitter<any>();\n  @Output('psYReachStart'    ) PS_Y_REACH_START       = new EventEmitter<any>();\n  @Output('psXReachEnd'      ) PS_X_REACH_END         = new EventEmitter<any>();\n  @Output('psXReachStart'    ) PS_X_REACH_START       = new EventEmitter<any>();\n\n  private emit(event: any) { this[event.type.replace(/-/g, '_').toUpperCase()].emit(event); }\n\n  @HostListener('ps-scroll-y', ['$event'])       psScrollY(event: any) { this.emit(event); }\n  @HostListener('ps-scroll-x', ['$event'])       psScrollX(event: any) { this.emit(event); }\n\n  @HostListener('ps-scroll-up', ['$event'])      psScrollUp(event: any) { this.emit(event); }\n  @HostListener('ps-scroll-down', ['$event'])    psScrollDown(event: any) { this.emit(event); }\n  @HostListener('ps-scroll-left', ['$event'])    psScrollLeft(event: any) { this.emit(event); }\n  @HostListener('ps-scroll-right', ['$event'])   psScrollRight(event): any { this.emit(event); }\n\n  @HostListener('ps-y-reach-end', ['$event'])    psReachEndY(event): any { this.emit(event); }\n  @HostListener('ps-y-reach-start', ['$event'])  psReachStartY(event): any { this.emit(event); }\n  @HostListener('ps-x-reach-end', ['$event'])    psReachEndX(event): any { this.emit(event); }\n  @HostListener('ps-x-reach-start', ['$event'])  psReachStartX(event): any { this.emit(event); }\n\n  constructor(@Optional() private defaults: PerfectScrollbarConfig, private zone: NgZone,\n    public elementRef: ElementRef, private differs: KeyValueDiffers) {}\n\n  ngOnDestroy() {\n    if (this.ro) {\n      this.ro.disconnect();\n    }\n\n    if (this.timeout) {\n      window.clearTimeout(this.timeout);\n    }\n\n    if (this.ps) {\n      if (this.runInsideAngular) {\n        this.ps.destroy();\n      } else {\n        this.zone.runOutsideAngular(() => {\n          this.ps.destroy();\n        });\n      }\n    }\n\n    this.ps = null;\n  }\n\n  ngDoCheck() {\n    if (!this.disabled && this.configDiff) {\n      const changes = this.configDiff.diff(this.config || {});\n\n      if (changes) {\n        this.ngOnDestroy();\n\n        this.ngAfterViewInit();\n      }\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['fxHide']) {\n      changes['hidden'] = changes['fxHide'];\n    } else if (changes['fxShow']) {\n      changes['hidden'] = changes['fxShow'];\n\n      changes['hidden'].currentValue = !changes['fxShow'].currentValue;\n      changes['hidden'].previousValue = !changes['fxShow'].previousValue;\n    }\n\n    if (changes['disabled'] && !changes['disabled'].isFirstChange()) {\n      if (changes['disabled'].currentValue !== changes['disabled'].previousValue) {\n        if (changes['disabled'].currentValue === true) {\n         this.ngOnDestroy();\n        } else if (changes['disabled'].currentValue === false) {\n          this.ngAfterViewInit();\n        }\n      }\n    } else if (changes['hidden'] && !changes['hidden'].isFirstChange()) {\n      if (changes['hidden'].currentValue !== changes['hidden'].previousValue) {\n        if (changes['hidden'].currentValue === false) {\n          this.update();\n        }\n      }\n    }\n  }\n\n  ngAfterViewInit() {\n    if (!this.disabled) {\n      const config = new PerfectScrollbarConfig(this.defaults);\n\n      config.assign(this.config);\n\n      if (this.runInsideAngular) {\n        this.ps = new PerfectScrollbar(this.elementRef.nativeElement, config);\n      } else {\n        this.zone.runOutsideAngular(() => {\n          this.ps = new PerfectScrollbar(this.elementRef.nativeElement, config);\n        });\n      }\n\n      if (!this.configDiff) {\n        this.configDiff = this.differs.find(this.config || {}).create(null);\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.ro = new ResizeObserver((entries, observer) => {\n          this.update();\n        });\n\n        this.ro.observe(this.elementRef.nativeElement);\n      });\n    }\n  }\n\n  update() {\n    if (this.timeout) {\n      window.clearTimeout(this.timeout);\n    }\n\n    this.timeout = window.setTimeout(() => {\n      if (!this.disabled && this.configDiff) {\n        try {\n          if (this.runInsideAngular) {\n            this.ps.update();\n          } else {\n            this.zone.runOutsideAngular(() => {\n              this.ps.update();\n            });\n          }\n        } catch (error) {\n          // Update can be finished after destroy so catch errors\n        }\n      }\n    }, 0);\n  }\n\n  geometry(prefix: string = 'scroll'): Geometry {\n    return new Geometry(\n      this.elementRef.nativeElement[prefix + 'Left'],\n      this.elementRef.nativeElement[prefix + 'Top'],\n      this.elementRef.nativeElement[prefix + 'Width'],\n      this.elementRef.nativeElement[prefix + 'Height']\n    );\n  }\n\n  position(absolute: boolean = false): Position {\n    if (!absolute) {\n      return new Position(\n        this.ps.reach.x,\n        this.ps.reach.y\n      );\n    } else {\n      return new Position(\n        this.elementRef.nativeElement.scrollLeft,\n        this.elementRef.nativeElement.scrollTop\n      );\n    }\n  }\n\n  scrollable(direction: string = 'any'): boolean {\n    const element = this.elementRef.nativeElement;\n\n    if (direction === 'any') {\n      return element.classList.contains('ps--active-x') ||\n        element.classList.contains('ps--active-y');\n    } else if (direction === 'both') {\n      return element.classList.contains('ps--active-x') &&\n        element.classList.contains('ps--active-y');\n    } else {\n      return element.classList.contains('ps--active-' + direction);\n    }\n  }\n\n  scrollTo(x: number, y?: number, speed?: number) {\n    if (!this.disabled) {\n      if (y == null && speed == null) {\n        console.warn('Deprecated use of scrollTo, use the scrollToY function instead!');\n\n        this.animateScrolling('scrollTop', x, speed);\n      } else {\n        if (x != null) {\n          this.animateScrolling('scrollLeft', x, speed);\n        }\n\n        if (y != null) {\n          this.animateScrolling('scrollTop', y, speed);\n        }\n      }\n    }\n  }\n\n  scrollToX(x: number, speed?: number) {\n    this.animateScrolling('scrollLeft', x, speed);\n  }\n\n  scrollToY(y: number, speed?: number) {\n    this.animateScrolling('scrollTop', y, speed);\n  }\n\n  scrollToTop(offset?: number, speed?: number) {\n    this.animateScrolling('scrollTop', (offset || 0), speed);\n  }\n\n  scrollToLeft(offset?: number, speed?: number) {\n    this.animateScrolling('scrollLeft', (offset || 0), speed);\n  }\n\n  scrollToRight(offset?: number, speed?: number) {\n    const left = this.elementRef.nativeElement.scrollWidth -\n      this.elementRef.nativeElement.clientWidth;\n\n    this.animateScrolling('scrollLeft', left - (offset || 0), speed);\n  }\n\n  scrollToBottom(offset?: number, speed?: number) {\n    const top = this.elementRef.nativeElement.scrollHeight -\n      this.elementRef.nativeElement.clientHeight;\n\n    this.animateScrolling('scrollTop', top - (offset || 0), speed);\n  }\n\n  animateScrolling(target: string, value: number, speed?: number) {\n    if (!speed) {\n      const oldValue = this.elementRef.nativeElement[target];\n\n      this.elementRef.nativeElement[target] = value;\n\n      if (value !== oldValue) {\n        this.ps.update();\n      }\n    } else if (value !== this.elementRef.nativeElement[target]) {\n      let newValue = 0;\n      let scrollCount = 0;\n\n      let oldTimestamp = performance.now();\n      let oldValue = this.elementRef.nativeElement[target];\n\n      const cosParameter = (oldValue - value) / 2;\n\n      const step = (newTimestamp) => {\n        scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n\n        newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n\n        // Only continue animation if scroll position has not changed\n        if (this.elementRef.nativeElement[target] === oldValue) {\n          if (scrollCount >= Math.PI) {\n            this.animateScrolling(target, value, 0);\n          } else {\n            this.elementRef.nativeElement[target] = newValue;\n\n            // On a zoomed out page the resulting offset may differ\n            oldValue = this.elementRef.nativeElement[target];\n\n            this.ps.update();\n\n            oldTimestamp = newTimestamp;\n\n            window.requestAnimationFrame(step);\n          }\n        }\n      };\n\n      window.requestAnimationFrame(step);\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./src/lib/perfect-scrollbar.directive.ts","import 'rxjs/add/operator/throttleTime';\nimport 'rxjs/add/operator/distinctUntilChanged';\n\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport { Component, OnInit, OnDestroy, DoCheck } from '@angular/core';\nimport { ElementRef, ChangeDetectorRef, ViewEncapsulation } from '@angular/core';\nimport { Input, Output, EventEmitter, HostBinding, HostListener, ViewChild } from '@angular/core';\n\nimport { PerfectScrollbarDirective } from './perfect-scrollbar.directive';\nimport { Position, PerfectScrollbarConfigInterface } from './perfect-scrollbar.interfaces';\n\n@Component({\n  selector: 'perfect-scrollbar',\n  template: require('./perfect-scrollbar.component.html'),\n  styles: [ require('./perfect-scrollbar.component.css') ],\n  encapsulation: ViewEncapsulation.None\n})\nexport class PerfectScrollbarComponent implements OnInit, OnDestroy, DoCheck {\n  public states: any = {};\n  public notify: boolean = null;\n\n  public userInteraction: boolean = false;\n  public allowPropagation: boolean = false;\n\n  private cancelEvent: Event = null;\n\n  private timeoutState: number = null;\n  private timeoutScroll: number = null;\n\n  private usePropagationX: boolean = false;\n  private usePropagationY: boolean = false;\n\n  private statesSub: Subscription = null;\n  private statesUpdate: Subject<string> = new Subject();\n\n  private activeSub: Subscription = null;\n  private activeUpdate: Subject<boolean> = new Subject();\n\n  @Input() fxShow: boolean = true;\n  @Input() fxHide: boolean = false;\n\n  @HostBinding('hidden')\n  @Input() hidden: boolean = false;\n\n  @Input() disabled: boolean = false;\n\n  @Input() usePSClass: boolean = true;\n\n  @HostBinding('class.ps-show-limits')\n  @Input() autoPropagation: boolean = false;\n\n  @HostBinding('class.ps-show-active')\n  @Input() scrollIndicators: boolean = false;\n\n  @Input() runInsideAngular: boolean = false;\n\n  @Input() config: PerfectScrollbarConfigInterface;\n\n  @ViewChild(PerfectScrollbarDirective) directiveRef: PerfectScrollbarDirective;\n\n  @Output('psScrollY'        ) PS_SCROLL_Y            = new EventEmitter<any>();\n  @Output('psScrollX'        ) PS_SCROLL_X            = new EventEmitter<any>();\n\n  @Output('psScrollUp'       ) PS_SCROLL_UP           = new EventEmitter<any>();\n  @Output('psScrollDown'     ) PS_SCROLL_DOWN         = new EventEmitter<any>();\n  @Output('psScrollLeft'     ) PS_SCROLL_LEFT         = new EventEmitter<any>();\n  @Output('psScrollRight'    ) PS_SCROLL_RIGHT        = new EventEmitter<any>();\n\n  @Output('psYReachEnd'      ) PS_Y_REACH_END         = new EventEmitter<any>();\n  @Output('psYReachStart'    ) PS_Y_REACH_START       = new EventEmitter<any>();\n  @Output('psXReachEnd'      ) PS_X_REACH_END         = new EventEmitter<any>();\n  @Output('psXReachStart'    ) PS_X_REACH_START       = new EventEmitter<any>();\n\n  @HostListener('document:touchstart', ['$event']) onGeneratedEvent(event: any) {\n    // Stop the generated event from reaching window for PS to work correctly\n    if (event['psGenerated']) {\n      event.stopPropagation();\n    }\n  }\n\n  constructor(private elementRef: ElementRef, private cdRef: ChangeDetectorRef) {}\n\n  ngOnInit() {\n    this.activeSub = this.activeUpdate\n      .distinctUntilChanged()\n      .subscribe((active: boolean) => {\n        this.allowPropagation = active;\n      });\n\n    this.statesSub = this.statesUpdate\n      .distinctUntilChanged()\n      .subscribe((state: string) => {\n        window.clearTimeout(this.timeoutState);\n\n        if (state !== 'x' && state !== 'y') {\n          this.notify = true;\n\n          this.states[state] = true;\n\n          if (state === 'top') {\n            this.states.bottom = false;\n          } else if (state === 'bottom') {\n            this.states.top = false;\n          } else if (state === 'left') {\n            this.states.rights = false;\n          } else if (state === 'rights') {\n            this.states.left = false;\n          }\n\n          this.timeoutState = window.setTimeout(() => {\n            this.notify = false;\n\n            if (this.autoPropagation && this.userInteraction &&\n               ((!this.usePropagationX && (this.states.left || this.states.right)) ||\n               (!this.usePropagationY && (this.states.top || this.states.bottom))))\n            {\n              this.allowPropagation = true;\n            }\n\n            this.cdRef.markForCheck();\n          }, 300);\n        }Â else {\n          this.notify = false;\n\n          if (state === 'x') {\n            this.states.left = false;\n            this.states.right = false;\n          } else if (state === 'y') {\n            this.states.top = false;\n            this.states.bottom = false;\n          }\n\n          this.userInteraction = true;\n\n          if (this.autoPropagation &&\n            (!this.usePropagationX || !this.usePropagationY))\n          {\n            this.allowPropagation = false;\n\n            if (this.cancelEvent) {\n              this.elementRef.nativeElement.dispatchEvent(this.cancelEvent);\n\n              this.cancelEvent = null;\n            }\n          } else if (this.scrollIndicators) {\n            this.notify = true;\n\n            this.timeoutState = window.setTimeout(() => {\n              this.notify = false;\n\n              this.cdRef.markForCheck();\n            }, 300);\n          }\n        }\n\n        this.cdRef.markForCheck();\n        this.cdRef.detectChanges();\n      });\n  }\n\n  ngOnDestroy() {\n    if (this.activeSub) {\n      this.activeSub.unsubscribe();\n    }\n\n    if (this.statesSub) {\n      this.statesSub.unsubscribe();\n    }\n\n    window.clearTimeout(this.timeoutState);\n    window.clearTimeout(this.timeoutScroll);\n  }\n\n  ngDoCheck() {\n    if (!this.disabled && this.autoPropagation && this.directiveRef) {\n      const element = this.directiveRef.elementRef.nativeElement;\n\n      this.usePropagationX = !element.classList.contains('ps--active-x');\n      this.usePropagationY = !element.classList.contains('ps--active-y');\n\n      this.activeUpdate.next(this.usePropagationX && this.usePropagationY);\n    }\n  }\n\n  getConfig(): PerfectScrollbarConfigInterface {\n    const config = this.config || {};\n\n    if (this.autoPropagation) {\n      config.swipePropagation = true;\n      config.wheelPropagation = true;\n    }\n\n    return config;\n  }\n\n  update() {\n    console.warn('Deprecated function, update needs to be called through directiveRef!');\n\n    this.directiveRef.update();\n  }\n\n  scrollTo(x: number, y?: number) {\n    console.warn('Deprecated function, scrollTo needs to be called through directiveRef!');\n\n    this.directiveRef.scrollTo(x, y);\n  }\n\n  scrollToTop(offset: number = 0) {\n    console.warn('Deprecated function, scrollToTop needs to be called through directiveRef!');\n\n    this.directiveRef.scrollToTop(offset);\n  }\n\n  scrollToLeft(offset: number = 0) {\n    console.warn('Deprecated function, scrollToLeft needs to be called through directiveRef!');\n\n    this.directiveRef.scrollToLeft(offset);\n  }\n\n  scrollToRight(offset: number = 0) {\n    console.warn('Deprecated function, scrollToRight needs to be called through directiveRef!');\n\n    this.directiveRef.scrollToRight(offset);\n  }\n\n  scrollToBottom(offset: number = 0) {\n    console.warn('Deprecated function, scrollToBottom needs to be called through directiveRef!');\n\n    this.directiveRef.scrollToBottom(offset);\n  }\n\n  onTouchEnd(event: Event = null) {\n    if (!this.disabled && this.autoPropagation &&\n       (!this.usePropagationX || !this.usePropagationY))\n    {\n      this.cancelEvent = null;\n\n      this.allowPropagation = false;\n    }\n  }\n\n  onTouchMove(event: Event = null) {\n    if (!this.disabled && this.autoPropagation && !this.allowPropagation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  onTouchStart(event: Event = null) {\n    if (!this.disabled && this.autoPropagation) {\n      this.userInteraction = true;\n\n      if (this.allowPropagation) {\n        // PS stops the touchmove event so lets re-emit it here\n        if (this.elementRef.nativeElement) {\n          const newEvent = new MouseEvent('touchstart', event);\n          this.cancelEvent = new MouseEvent('touchmove', event);\n\n          newEvent['psGenerated'] = this.cancelEvent['psGenerated'] = true;\n          newEvent['touches'] = this.cancelEvent['touches'] = event['touches'];\n          newEvent['targetTouches'] = this.cancelEvent['targetTouches'] = event['targetTouches'];\n\n          this.elementRef.nativeElement.dispatchEvent(newEvent);\n        }\n      }\n\n      this.cdRef.detectChanges();\n    }\n  }\n\n  onWheelEvent(event: Event = null) {\n    if (!this.disabled && this.autoPropagation) {\n      this.userInteraction = true;\n\n      if (!this.allowPropagation) {\n        event.preventDefault();\n        event.stopPropagation();\n      } else if (!this.usePropagationX || !this.usePropagationY) {\n        this.allowPropagation = false;\n      }\n\n      this.cdRef.detectChanges();\n    }\n  }\n\n  onScrollEvent(event: Event = null, state: string) {\n    if (!this.disabled && (this.autoPropagation || this.scrollIndicators) &&\n       (!event || event.currentTarget === event.target))\n    {\n      this.statesUpdate.next(state);\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./src/lib/perfect-scrollbar.component.ts","export { PerfectScrollbarComponent } from './lib/perfect-scrollbar.component';\nexport { PerfectScrollbarDirective } from './lib/perfect-scrollbar.directive';\n\nexport {\n  Geometry,\n  PerfectScrollbarConfig,\n  PerfectScrollbarConfigInterface\n} from './lib/perfect-scrollbar.interfaces';\n\nexport {\n  PerfectScrollbarModule,\n  PERFECT_SCROLLBAR_CONFIG\n} from './lib/perfect-scrollbar.module';\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./src/index.ts","module.exports = \"\\\"use strict\\\";\\nvar Observable_1 = require('../../Observable');\\nvar throttleTime_1 = require('../../operator/throttleTime');\\nObservable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\\n//# sourceMappingURL=throttleTime.js.map\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/throttleTime.js\n// module id = 5\n// module chunks = 0 1","module.exports = \"\\\"use strict\\\";\\nvar Observable_1 = require('../../Observable');\\nvar distinctUntilChanged_1 = require('../../operator/distinctUntilChanged');\\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\\n//# sourceMappingURL=distinctUntilChanged.js.map\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/distinctUntilChanged.js\n// module id = 6\n// module chunks = 0 1","module.exports = \"\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || function (d, b) {\\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\\n    function __() { this.constructor = d; }\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n};\\nvar Observable_1 = require('./Observable');\\nvar Subscriber_1 = require('./Subscriber');\\nvar Subscription_1 = require('./Subscription');\\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\\nvar SubjectSubscription_1 = require('./SubjectSubscription');\\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\\n/**\\n * @class SubjectSubscriber<T>\\n */\\nvar SubjectSubscriber = (function (_super) {\\n    __extends(SubjectSubscriber, _super);\\n    function SubjectSubscriber(destination) {\\n        _super.call(this, destination);\\n        this.destination = destination;\\n    }\\n    return SubjectSubscriber;\\n}(Subscriber_1.Subscriber));\\nexports.SubjectSubscriber = SubjectSubscriber;\\n/**\\n * @class Subject<T>\\n */\\nvar Subject = (function (_super) {\\n    __extends(Subject, _super);\\n    function Subject() {\\n        _super.call(this);\\n        this.observers = [];\\n        this.closed = false;\\n        this.isStopped = false;\\n        this.hasError = false;\\n        this.thrownError = null;\\n    }\\n    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\\n        return new SubjectSubscriber(this);\\n    };\\n    Subject.prototype.lift = function (operator) {\\n        var subject = new AnonymousSubject(this, this);\\n        subject.operator = operator;\\n        return subject;\\n    };\\n    Subject.prototype.next = function (value) {\\n        if (this.closed) {\\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\\n        }\\n        if (!this.isStopped) {\\n            var observers = this.observers;\\n            var len = observers.length;\\n            var copy = observers.slice();\\n            for (var i = 0; i < len; i++) {\\n                copy[i].next(value);\\n            }\\n        }\\n    };\\n    Subject.prototype.error = function (err) {\\n        if (this.closed) {\\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\\n        }\\n        this.hasError = true;\\n        this.thrownError = err;\\n        this.isStopped = true;\\n        var observers = this.observers;\\n        var len = observers.length;\\n        var copy = observers.slice();\\n        for (var i = 0; i < len; i++) {\\n            copy[i].error(err);\\n        }\\n        this.observers.length = 0;\\n    };\\n    Subject.prototype.complete = function () {\\n        if (this.closed) {\\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\\n        }\\n        this.isStopped = true;\\n        var observers = this.observers;\\n        var len = observers.length;\\n        var copy = observers.slice();\\n        for (var i = 0; i < len; i++) {\\n            copy[i].complete();\\n        }\\n        this.observers.length = 0;\\n    };\\n    Subject.prototype.unsubscribe = function () {\\n        this.isStopped = true;\\n        this.closed = true;\\n        this.observers = null;\\n    };\\n    Subject.prototype._trySubscribe = function (subscriber) {\\n        if (this.closed) {\\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\\n        }\\n        else {\\n            return _super.prototype._trySubscribe.call(this, subscriber);\\n        }\\n    };\\n    Subject.prototype._subscribe = function (subscriber) {\\n        if (this.closed) {\\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\\n        }\\n        else if (this.hasError) {\\n            subscriber.error(this.thrownError);\\n            return Subscription_1.Subscription.EMPTY;\\n        }\\n        else if (this.isStopped) {\\n            subscriber.complete();\\n            return Subscription_1.Subscription.EMPTY;\\n        }\\n        else {\\n            this.observers.push(subscriber);\\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\\n        }\\n    };\\n    Subject.prototype.asObservable = function () {\\n        var observable = new Observable_1.Observable();\\n        observable.source = this;\\n        return observable;\\n    };\\n    Subject.create = function (destination, source) {\\n        return new AnonymousSubject(destination, source);\\n    };\\n    return Subject;\\n}(Observable_1.Observable));\\nexports.Subject = Subject;\\n/**\\n * @class AnonymousSubject<T>\\n */\\nvar AnonymousSubject = (function (_super) {\\n    __extends(AnonymousSubject, _super);\\n    function AnonymousSubject(destination, source) {\\n        _super.call(this);\\n        this.destination = destination;\\n        this.source = source;\\n    }\\n    AnonymousSubject.prototype.next = function (value) {\\n        var destination = this.destination;\\n        if (destination && destination.next) {\\n            destination.next(value);\\n        }\\n    };\\n    AnonymousSubject.prototype.error = function (err) {\\n        var destination = this.destination;\\n        if (destination && destination.error) {\\n            this.destination.error(err);\\n        }\\n    };\\n    AnonymousSubject.prototype.complete = function () {\\n        var destination = this.destination;\\n        if (destination && destination.complete) {\\n            this.destination.complete();\\n        }\\n    };\\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\\n        var source = this.source;\\n        if (source) {\\n            return this.source.subscribe(subscriber);\\n        }\\n        else {\\n            return Subscription_1.Subscription.EMPTY;\\n        }\\n    };\\n    return AnonymousSubject;\\n}(Subject));\\nexports.AnonymousSubject = AnonymousSubject;\\n//# sourceMappingURL=Subject.js.map\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/Subject.js\n// module id = 7\n// module chunks = 0 1","module.exports = \"/*!\\n * perfect-scrollbar v1.2.0\\n * (c) 2017 Hyunje Jun\\n * @license MIT\\n */\\nfunction get(element) {\\n  return getComputedStyle(element);\\n}\\n\\nfunction set(element, obj) {\\n  for (var key in obj) {\\n    var val = obj[key];\\n    if (typeof val === 'number') {\\n      val = val + \\\"px\\\";\\n    }\\n    element.style[key] = val;\\n  }\\n  return element;\\n}\\n\\nfunction div(className) {\\n  var div = document.createElement('div');\\n  div.className = className;\\n  return div;\\n}\\n\\nvar elMatches =\\n  Element.prototype.matches ||\\n  Element.prototype.webkitMatchesSelector ||\\n  Element.prototype.msMatchesSelector;\\n\\nfunction matches(element, query) {\\n  if (!elMatches) {\\n    throw new Error('No element matching method supported');\\n  }\\n\\n  return elMatches.call(element, query);\\n}\\n\\nfunction remove(element) {\\n  if (element.remove) {\\n    element.remove();\\n  } else {\\n    if (element.parentNode) {\\n      element.parentNode.removeChild(element);\\n    }\\n  }\\n}\\n\\nfunction queryChildren(element, selector) {\\n  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }\\n  );\\n}\\n\\nvar cls = {\\n  main: 'ps',\\n  element: {\\n    thumb: function (x) { return (\\\"ps__thumb-\\\" + x); },\\n    rail: function (x) { return (\\\"ps__rail-\\\" + x); },\\n    consuming: 'ps__child--consume',\\n  },\\n  state: {\\n    focus: 'ps--focus',\\n    active: function (x) { return (\\\"ps--active-\\\" + x); },\\n    scrolling: function (x) { return (\\\"ps--scrolling-\\\" + x); },\\n  },\\n};\\n\\n/*\\n * Helper methods\\n */\\nvar scrollingClassTimeout = { x: null, y: null };\\n\\nfunction addScrollingClass(i, x) {\\n  var classList = i.element.classList;\\n  var className = cls.state.scrolling(x);\\n\\n  if (classList.contains(className)) {\\n    clearTimeout(scrollingClassTimeout[x]);\\n  } else {\\n    classList.add(className);\\n  }\\n}\\n\\nfunction removeScrollingClass(i, x) {\\n  scrollingClassTimeout[x] = setTimeout(\\n    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },\\n    i.settings.scrollingThreshold\\n  );\\n}\\n\\nfunction setScrollingClassInstantly(i, x) {\\n  addScrollingClass(i, x);\\n  removeScrollingClass(i, x);\\n}\\n\\nvar EventElement = function EventElement(element) {\\n  this.element = element;\\n  this.handlers = {};\\n};\\n\\nvar prototypeAccessors = { isEmpty: { configurable: true } };\\n\\nEventElement.prototype.bind = function bind (eventName, handler) {\\n  if (typeof this.handlers[eventName] === 'undefined') {\\n    this.handlers[eventName] = [];\\n  }\\n  this.handlers[eventName].push(handler);\\n  this.element.addEventListener(eventName, handler, false);\\n};\\n\\nEventElement.prototype.unbind = function unbind (eventName, target) {\\n    var this$1 = this;\\n\\n  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {\\n    if (target && handler !== target) {\\n      return true;\\n    }\\n    this$1.element.removeEventListener(eventName, handler, false);\\n    return false;\\n  });\\n};\\n\\nEventElement.prototype.unbindAll = function unbindAll () {\\n    var this$1 = this;\\n\\n  for (var name in this$1.handlers) {\\n    this$1.unbind(name);\\n  }\\n};\\n\\nprototypeAccessors.isEmpty.get = function () {\\n    var this$1 = this;\\n\\n  return Object.keys(this.handlers).every(\\n    function (key) { return this$1.handlers[key].length === 0; }\\n  );\\n};\\n\\nObject.defineProperties( EventElement.prototype, prototypeAccessors );\\n\\nvar EventManager = function EventManager() {\\n  this.eventElements = [];\\n};\\n\\nEventManager.prototype.eventElement = function eventElement (element) {\\n  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];\\n  if (!ee) {\\n    ee = new EventElement(element);\\n    this.eventElements.push(ee);\\n  }\\n  return ee;\\n};\\n\\nEventManager.prototype.bind = function bind (element, eventName, handler) {\\n  this.eventElement(element).bind(eventName, handler);\\n};\\n\\nEventManager.prototype.unbind = function unbind (element, eventName, handler) {\\n  var ee = this.eventElement(element);\\n  ee.unbind(eventName, handler);\\n\\n  if (ee.isEmpty) {\\n    // remove\\n    this.eventElements.splice(this.eventElements.indexOf(ee), 1);\\n  }\\n};\\n\\nEventManager.prototype.unbindAll = function unbindAll () {\\n  this.eventElements.forEach(function (e) { return e.unbindAll(); });\\n  this.eventElements = [];\\n};\\n\\nEventManager.prototype.once = function once (element, eventName, handler) {\\n  var ee = this.eventElement(element);\\n  var onceHandler = function (evt) {\\n    ee.unbind(eventName, onceHandler);\\n    handler(evt);\\n  };\\n  ee.bind(eventName, onceHandler);\\n};\\n\\nfunction createEvent(name) {\\n  if (typeof window.CustomEvent === 'function') {\\n    return new CustomEvent(name);\\n  } else {\\n    var evt = document.createEvent('CustomEvent');\\n    evt.initCustomEvent(name, false, false, undefined);\\n    return evt;\\n  }\\n}\\n\\nvar processScrollDiff = function(\\n  i,\\n  axis,\\n  diff,\\n  useScrollingClass,\\n  forceFireReachEvent\\n) {\\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\\n\\n  var fields;\\n  if (axis === 'top') {\\n    fields = [\\n      'contentHeight',\\n      'containerHeight',\\n      'scrollTop',\\n      'y',\\n      'up',\\n      'down' ];\\n  } else if (axis === 'left') {\\n    fields = [\\n      'contentWidth',\\n      'containerWidth',\\n      'scrollLeft',\\n      'x',\\n      'left',\\n      'right' ];\\n  } else {\\n    throw new Error('A proper axis should be provided');\\n  }\\n\\n  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);\\n};\\n\\nfunction processScrollDiff$1(\\n  i,\\n  diff,\\n  ref,\\n  useScrollingClass,\\n  forceFireReachEvent\\n) {\\n  var contentHeight = ref[0];\\n  var containerHeight = ref[1];\\n  var scrollTop = ref[2];\\n  var y = ref[3];\\n  var up = ref[4];\\n  var down = ref[5];\\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\\n\\n  var element = i.element;\\n\\n  // reset reach\\n  i.reach[y] = null;\\n\\n  // 1 for subpixel rounding\\n  if (element[scrollTop] < 1) {\\n    i.reach[y] = 'start';\\n  }\\n\\n  // 1 for subpixel rounding\\n  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {\\n    i.reach[y] = 'end';\\n  }\\n\\n  if (diff) {\\n    element.dispatchEvent(createEvent((\\\"ps-scroll-\\\" + y)));\\n\\n    if (diff < 0) {\\n      element.dispatchEvent(createEvent((\\\"ps-scroll-\\\" + up)));\\n    } else if (diff > 0) {\\n      element.dispatchEvent(createEvent((\\\"ps-scroll-\\\" + down)));\\n    }\\n\\n    if (useScrollingClass) {\\n      setScrollingClassInstantly(i, y);\\n    }\\n  }\\n\\n  if (i.reach[y] && (diff || forceFireReachEvent)) {\\n    element.dispatchEvent(createEvent((\\\"ps-\\\" + y + \\\"-reach-\\\" + (i.reach[y]))));\\n  }\\n}\\n\\nfunction toInt(x) {\\n  return parseInt(x, 10) || 0;\\n}\\n\\nfunction isEditable(el) {\\n  return (\\n    matches(el, 'input,[contenteditable]') ||\\n    matches(el, 'select,[contenteditable]') ||\\n    matches(el, 'textarea,[contenteditable]') ||\\n    matches(el, 'button,[contenteditable]')\\n  );\\n}\\n\\nfunction outerWidth(element) {\\n  var styles = get(element);\\n  return (\\n    toInt(styles.width) +\\n    toInt(styles.paddingLeft) +\\n    toInt(styles.paddingRight) +\\n    toInt(styles.borderLeftWidth) +\\n    toInt(styles.borderRightWidth)\\n  );\\n}\\n\\nvar env = {\\n  isWebKit: document && 'WebkitAppearance' in document.documentElement.style,\\n  supportsTouch:\\n    window &&\\n    ('ontouchstart' in window ||\\n      (window.DocumentTouch && document instanceof window.DocumentTouch)),\\n  supportsIePointer: navigator && navigator.msMaxTouchPoints,\\n};\\n\\nvar updateGeometry = function(i) {\\n  var element = i.element;\\n\\n  i.containerWidth = element.clientWidth;\\n  i.containerHeight = element.clientHeight;\\n  i.contentWidth = element.scrollWidth;\\n  i.contentHeight = element.scrollHeight;\\n\\n  if (!element.contains(i.scrollbarXRail)) {\\n    // clean up and append\\n    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }\\n    );\\n    element.appendChild(i.scrollbarXRail);\\n  }\\n  if (!element.contains(i.scrollbarYRail)) {\\n    // clean up and append\\n    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }\\n    );\\n    element.appendChild(i.scrollbarYRail);\\n  }\\n\\n  if (\\n    !i.settings.suppressScrollX &&\\n    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth\\n  ) {\\n    i.scrollbarXActive = true;\\n    i.railXWidth = i.containerWidth - i.railXMarginWidth;\\n    i.railXRatio = i.containerWidth / i.railXWidth;\\n    i.scrollbarXWidth = getThumbSize(\\n      i,\\n      toInt(i.railXWidth * i.containerWidth / i.contentWidth)\\n    );\\n    i.scrollbarXLeft = toInt(\\n      (i.negativeScrollAdjustment + element.scrollLeft) *\\n        (i.railXWidth - i.scrollbarXWidth) /\\n        (i.contentWidth - i.containerWidth)\\n    );\\n  } else {\\n    i.scrollbarXActive = false;\\n  }\\n\\n  if (\\n    !i.settings.suppressScrollY &&\\n    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight\\n  ) {\\n    i.scrollbarYActive = true;\\n    i.railYHeight = i.containerHeight - i.railYMarginHeight;\\n    i.railYRatio = i.containerHeight / i.railYHeight;\\n    i.scrollbarYHeight = getThumbSize(\\n      i,\\n      toInt(i.railYHeight * i.containerHeight / i.contentHeight)\\n    );\\n    i.scrollbarYTop = toInt(\\n      element.scrollTop *\\n        (i.railYHeight - i.scrollbarYHeight) /\\n        (i.contentHeight - i.containerHeight)\\n    );\\n  } else {\\n    i.scrollbarYActive = false;\\n  }\\n\\n  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {\\n    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;\\n  }\\n  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {\\n    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;\\n  }\\n\\n  updateCss(element, i);\\n\\n  if (i.scrollbarXActive) {\\n    element.classList.add(cls.state.active('x'));\\n  } else {\\n    element.classList.remove(cls.state.active('x'));\\n    i.scrollbarXWidth = 0;\\n    i.scrollbarXLeft = 0;\\n    element.scrollLeft = 0;\\n  }\\n  if (i.scrollbarYActive) {\\n    element.classList.add(cls.state.active('y'));\\n  } else {\\n    element.classList.remove(cls.state.active('y'));\\n    i.scrollbarYHeight = 0;\\n    i.scrollbarYTop = 0;\\n    element.scrollTop = 0;\\n  }\\n};\\n\\nfunction getThumbSize(i, thumbSize) {\\n  if (i.settings.minScrollbarLength) {\\n    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);\\n  }\\n  if (i.settings.maxScrollbarLength) {\\n    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);\\n  }\\n  return thumbSize;\\n}\\n\\nfunction updateCss(element, i) {\\n  var xRailOffset = { width: i.railXWidth };\\n  if (i.isRtl) {\\n    xRailOffset.left =\\n      i.negativeScrollAdjustment +\\n      element.scrollLeft +\\n      i.containerWidth -\\n      i.contentWidth;\\n  } else {\\n    xRailOffset.left = element.scrollLeft;\\n  }\\n  if (i.isScrollbarXUsingBottom) {\\n    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;\\n  } else {\\n    xRailOffset.top = i.scrollbarXTop + element.scrollTop;\\n  }\\n  set(i.scrollbarXRail, xRailOffset);\\n\\n  var yRailOffset = { top: element.scrollTop, height: i.railYHeight };\\n  if (i.isScrollbarYUsingRight) {\\n    if (i.isRtl) {\\n      yRailOffset.right =\\n        i.contentWidth -\\n        (i.negativeScrollAdjustment + element.scrollLeft) -\\n        i.scrollbarYRight -\\n        i.scrollbarYOuterWidth;\\n    } else {\\n      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;\\n    }\\n  } else {\\n    if (i.isRtl) {\\n      yRailOffset.left =\\n        i.negativeScrollAdjustment +\\n        element.scrollLeft +\\n        i.containerWidth * 2 -\\n        i.contentWidth -\\n        i.scrollbarYLeft -\\n        i.scrollbarYOuterWidth;\\n    } else {\\n      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;\\n    }\\n  }\\n  set(i.scrollbarYRail, yRailOffset);\\n\\n  set(i.scrollbarX, {\\n    left: i.scrollbarXLeft,\\n    width: i.scrollbarXWidth - i.railBorderXWidth,\\n  });\\n  set(i.scrollbarY, {\\n    top: i.scrollbarYTop,\\n    height: i.scrollbarYHeight - i.railBorderYWidth,\\n  });\\n}\\n\\nvar clickRail = function(i) {\\n  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });\\n  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {\\n    var positionTop =\\n      e.pageY -\\n      window.pageYOffset -\\n      i.scrollbarYRail.getBoundingClientRect().top;\\n    var direction = positionTop > i.scrollbarYTop ? 1 : -1;\\n\\n    i.element.scrollTop += direction * i.containerHeight;\\n    updateGeometry(i);\\n\\n    e.stopPropagation();\\n  });\\n\\n  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });\\n  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {\\n    var positionLeft =\\n      e.pageX -\\n      window.pageXOffset -\\n      i.scrollbarXRail.getBoundingClientRect().left;\\n    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;\\n\\n    i.element.scrollLeft += direction * i.containerWidth;\\n    updateGeometry(i);\\n\\n    e.stopPropagation();\\n  });\\n};\\n\\nvar dragThumb = function(i) {\\n  bindMouseScrollHandler(i, [\\n    'containerWidth',\\n    'contentWidth',\\n    'pageX',\\n    'railXWidth',\\n    'scrollbarX',\\n    'scrollbarXWidth',\\n    'scrollLeft',\\n    'x' ]);\\n  bindMouseScrollHandler(i, [\\n    'containerHeight',\\n    'contentHeight',\\n    'pageY',\\n    'railYHeight',\\n    'scrollbarY',\\n    'scrollbarYHeight',\\n    'scrollTop',\\n    'y' ]);\\n};\\n\\nfunction bindMouseScrollHandler(\\n  i,\\n  ref\\n) {\\n  var containerHeight = ref[0];\\n  var contentHeight = ref[1];\\n  var pageY = ref[2];\\n  var railYHeight = ref[3];\\n  var scrollbarY = ref[4];\\n  var scrollbarYHeight = ref[5];\\n  var scrollTop = ref[6];\\n  var y = ref[7];\\n\\n  var element = i.element;\\n\\n  var startingScrollTop = null;\\n  var startingMousePageY = null;\\n  var scrollBy = null;\\n\\n  function mouseMoveHandler(e) {\\n    element[scrollTop] =\\n      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);\\n    addScrollingClass(i, y);\\n    updateGeometry(i);\\n\\n    e.stopPropagation();\\n    e.preventDefault();\\n  }\\n\\n  function mouseUpHandler() {\\n    removeScrollingClass(i, y);\\n    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);\\n  }\\n\\n  i.event.bind(i[scrollbarY], 'mousedown', function (e) {\\n    startingScrollTop = element[scrollTop];\\n    startingMousePageY = e[pageY];\\n    scrollBy =\\n      (i[contentHeight] - i[containerHeight]) /\\n      (i[railYHeight] - i[scrollbarYHeight]);\\n\\n    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);\\n    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);\\n\\n    e.stopPropagation();\\n    e.preventDefault();\\n  });\\n}\\n\\nvar keyboard = function(i) {\\n  var element = i.element;\\n\\n  var elementHovered = function () { return matches(element, ':hover'); };\\n  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };\\n\\n  function shouldPreventDefault(deltaX, deltaY) {\\n    var scrollTop = element.scrollTop;\\n    if (deltaX === 0) {\\n      if (!i.scrollbarYActive) {\\n        return false;\\n      }\\n      if (\\n        (scrollTop === 0 && deltaY > 0) ||\\n        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)\\n      ) {\\n        return !i.settings.wheelPropagation;\\n      }\\n    }\\n\\n    var scrollLeft = element.scrollLeft;\\n    if (deltaY === 0) {\\n      if (!i.scrollbarXActive) {\\n        return false;\\n      }\\n      if (\\n        (scrollLeft === 0 && deltaX < 0) ||\\n        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)\\n      ) {\\n        return !i.settings.wheelPropagation;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  i.event.bind(i.ownerDocument, 'keydown', function (e) {\\n    if (\\n      (e.isDefaultPrevented && e.isDefaultPrevented()) ||\\n      e.defaultPrevented\\n    ) {\\n      return;\\n    }\\n\\n    if (!elementHovered() && !scrollbarFocused()) {\\n      return;\\n    }\\n\\n    var activeElement = document.activeElement\\n      ? document.activeElement\\n      : i.ownerDocument.activeElement;\\n    if (activeElement) {\\n      if (activeElement.tagName === 'IFRAME') {\\n        activeElement = activeElement.contentDocument.activeElement;\\n      } else {\\n        // go deeper if element is a webcomponent\\n        while (activeElement.shadowRoot) {\\n          activeElement = activeElement.shadowRoot.activeElement;\\n        }\\n      }\\n      if (isEditable(activeElement)) {\\n        return;\\n      }\\n    }\\n\\n    var deltaX = 0;\\n    var deltaY = 0;\\n\\n    switch (e.which) {\\n      case 37: // left\\n        if (e.metaKey) {\\n          deltaX = -i.contentWidth;\\n        } else if (e.altKey) {\\n          deltaX = -i.containerWidth;\\n        } else {\\n          deltaX = -30;\\n        }\\n        break;\\n      case 38: // up\\n        if (e.metaKey) {\\n          deltaY = i.contentHeight;\\n        } else if (e.altKey) {\\n          deltaY = i.containerHeight;\\n        } else {\\n          deltaY = 30;\\n        }\\n        break;\\n      case 39: // right\\n        if (e.metaKey) {\\n          deltaX = i.contentWidth;\\n        } else if (e.altKey) {\\n          deltaX = i.containerWidth;\\n        } else {\\n          deltaX = 30;\\n        }\\n        break;\\n      case 40: // down\\n        if (e.metaKey) {\\n          deltaY = -i.contentHeight;\\n        } else if (e.altKey) {\\n          deltaY = -i.containerHeight;\\n        } else {\\n          deltaY = -30;\\n        }\\n        break;\\n      case 32: // space bar\\n        if (e.shiftKey) {\\n          deltaY = i.containerHeight;\\n        } else {\\n          deltaY = -i.containerHeight;\\n        }\\n        break;\\n      case 33: // page up\\n        deltaY = i.containerHeight;\\n        break;\\n      case 34: // page down\\n        deltaY = -i.containerHeight;\\n        break;\\n      case 36: // home\\n        deltaY = i.contentHeight;\\n        break;\\n      case 35: // end\\n        deltaY = -i.contentHeight;\\n        break;\\n      default:\\n        return;\\n    }\\n\\n    if (i.settings.suppressScrollX && deltaX !== 0) {\\n      return;\\n    }\\n    if (i.settings.suppressScrollY && deltaY !== 0) {\\n      return;\\n    }\\n\\n    element.scrollTop -= deltaY;\\n    element.scrollLeft += deltaX;\\n    updateGeometry(i);\\n\\n    if (shouldPreventDefault(deltaX, deltaY)) {\\n      e.preventDefault();\\n    }\\n  });\\n};\\n\\nvar wheel = function(i) {\\n  var element = i.element;\\n\\n  function shouldPreventDefault(deltaX, deltaY) {\\n    var scrollTop = element.scrollTop;\\n    if (deltaX === 0) {\\n      if (!i.scrollbarYActive) {\\n        return false;\\n      }\\n      if (\\n        (scrollTop === 0 && deltaY > 0) ||\\n        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)\\n      ) {\\n        return !i.settings.wheelPropagation;\\n      }\\n    }\\n\\n    var scrollLeft = element.scrollLeft;\\n    if (deltaY === 0) {\\n      if (!i.scrollbarXActive) {\\n        return false;\\n      }\\n      if (\\n        (scrollLeft === 0 && deltaX < 0) ||\\n        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)\\n      ) {\\n        return !i.settings.wheelPropagation;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function getDeltaFromEvent(e) {\\n    var deltaX = e.deltaX;\\n    var deltaY = -1 * e.deltaY;\\n\\n    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {\\n      // OS X Safari\\n      deltaX = -1 * e.wheelDeltaX / 6;\\n      deltaY = e.wheelDeltaY / 6;\\n    }\\n\\n    if (e.deltaMode && e.deltaMode === 1) {\\n      // Firefox in deltaMode 1: Line scrolling\\n      deltaX *= 10;\\n      deltaY *= 10;\\n    }\\n\\n    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {\\n      // IE in some mouse drivers\\n      deltaX = 0;\\n      deltaY = e.wheelDelta;\\n    }\\n\\n    if (e.shiftKey) {\\n      // reverse axis with shift key\\n      return [-deltaY, -deltaX];\\n    }\\n    return [deltaX, deltaY];\\n  }\\n\\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\\n    // FIXME: this is a workaround for <select> issue in FF and IE #571\\n    if (!env.isWebKit && element.querySelector('select:focus')) {\\n      return true;\\n    }\\n\\n    if (!element.contains(target)) {\\n      return false;\\n    }\\n\\n    var cursor = target;\\n\\n    while (cursor && cursor !== element) {\\n      if (cursor.classList.contains(cls.element.consuming)) {\\n        return true;\\n      }\\n\\n      var style = get(cursor);\\n      var overflow = [style.overflow, style.overflowX, style.overflowY].join(\\n        ''\\n      );\\n\\n      // if scrollable\\n      if (overflow.match(/(scroll|auto)/)) {\\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\\n        if (maxScrollTop > 0) {\\n          if (\\n            !(cursor.scrollTop === 0 && deltaY > 0) &&\\n            !(cursor.scrollTop === maxScrollTop && deltaY < 0)\\n          ) {\\n            return true;\\n          }\\n        }\\n        var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;\\n        if (maxScrollLeft > 0) {\\n          if (\\n            !(cursor.scrollLeft === 0 && deltaX < 0) &&\\n            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)\\n          ) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      cursor = cursor.parentNode;\\n    }\\n\\n    return false;\\n  }\\n\\n  function mousewheelHandler(e) {\\n    var ref = getDeltaFromEvent(e);\\n    var deltaX = ref[0];\\n    var deltaY = ref[1];\\n\\n    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {\\n      return;\\n    }\\n\\n    var shouldPrevent = false;\\n    if (!i.settings.useBothWheelAxes) {\\n      // deltaX will only be used for horizontal scrolling and deltaY will\\n      // only be used for vertical scrolling - this is the default\\n      element.scrollTop -= deltaY * i.settings.wheelSpeed;\\n      element.scrollLeft += deltaX * i.settings.wheelSpeed;\\n    } else if (i.scrollbarYActive && !i.scrollbarXActive) {\\n      // only vertical scrollbar is active and useBothWheelAxes option is\\n      // active, so let's scroll vertical bar using both mouse wheel axes\\n      if (deltaY) {\\n        element.scrollTop -= deltaY * i.settings.wheelSpeed;\\n      } else {\\n        element.scrollTop += deltaX * i.settings.wheelSpeed;\\n      }\\n      shouldPrevent = true;\\n    } else if (i.scrollbarXActive && !i.scrollbarYActive) {\\n      // useBothWheelAxes and only horizontal bar is active, so use both\\n      // wheel axes for horizontal bar\\n      if (deltaX) {\\n        element.scrollLeft += deltaX * i.settings.wheelSpeed;\\n      } else {\\n        element.scrollLeft -= deltaY * i.settings.wheelSpeed;\\n      }\\n      shouldPrevent = true;\\n    }\\n\\n    updateGeometry(i);\\n\\n    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);\\n    if (shouldPrevent && !e.ctrlKey) {\\n      e.stopPropagation();\\n      e.preventDefault();\\n    }\\n  }\\n\\n  if (typeof window.onwheel !== 'undefined') {\\n    i.event.bind(element, 'wheel', mousewheelHandler);\\n  } else if (typeof window.onmousewheel !== 'undefined') {\\n    i.event.bind(element, 'mousewheel', mousewheelHandler);\\n  }\\n};\\n\\nvar touch = function(i) {\\n  if (!env.supportsTouch && !env.supportsIePointer) {\\n    return;\\n  }\\n\\n  var element = i.element;\\n\\n  function shouldStopOrPrevent(deltaX, deltaY) {\\n    var scrollTop = element.scrollTop;\\n    var scrollLeft = element.scrollLeft;\\n    var magnitudeX = Math.abs(deltaX);\\n    var magnitudeY = Math.abs(deltaY);\\n\\n    if (magnitudeY > magnitudeX) {\\n      // user is perhaps trying to swipe up/down the page\\n\\n      if (\\n        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||\\n        (deltaY > 0 && scrollTop === 0)\\n      ) {\\n        // set prevent for mobile Chrome refresh\\n        return {\\n          stop: !i.settings.swipePropagation,\\n          prevent: window.scrollY === 0,\\n        };\\n      }\\n    } else if (magnitudeX > magnitudeY) {\\n      // user is perhaps trying to swipe left/right across the page\\n\\n      if (\\n        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||\\n        (deltaX > 0 && scrollLeft === 0)\\n      ) {\\n        return { stop: !i.settings.swipePropagation, prevent: true };\\n      }\\n    }\\n\\n    return { stop: true, prevent: true };\\n  }\\n\\n  function applyTouchMove(differenceX, differenceY) {\\n    element.scrollTop -= differenceY;\\n    element.scrollLeft -= differenceX;\\n\\n    updateGeometry(i);\\n  }\\n\\n  var startOffset = {};\\n  var startTime = 0;\\n  var speed = {};\\n  var easingLoop = null;\\n  var inGlobalTouch = false;\\n  var inLocalTouch = false;\\n\\n  function globalTouchStart() {\\n    inGlobalTouch = true;\\n  }\\n  function globalTouchEnd() {\\n    inGlobalTouch = false;\\n  }\\n\\n  function getTouch(e) {\\n    if (e.targetTouches) {\\n      return e.targetTouches[0];\\n    } else {\\n      // Maybe IE pointer\\n      return e;\\n    }\\n  }\\n\\n  function shouldHandle(e) {\\n    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {\\n      return false;\\n    }\\n    if (e.targetTouches && e.targetTouches.length === 1) {\\n      return true;\\n    }\\n    if (\\n      e.pointerType &&\\n      e.pointerType !== 'mouse' &&\\n      e.pointerType !== e.MSPOINTER_TYPE_MOUSE\\n    ) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function touchStart(e) {\\n    if (!shouldHandle(e)) {\\n      return;\\n    }\\n\\n    inLocalTouch = true;\\n\\n    var touch = getTouch(e);\\n\\n    startOffset.pageX = touch.pageX;\\n    startOffset.pageY = touch.pageY;\\n\\n    startTime = new Date().getTime();\\n\\n    if (easingLoop !== null) {\\n      clearInterval(easingLoop);\\n    }\\n\\n    e.stopPropagation();\\n  }\\n\\n  function touchMove(e) {\\n    if (!inLocalTouch && i.settings.swipePropagation) {\\n      touchStart(e);\\n    }\\n    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {\\n      var touch = getTouch(e);\\n\\n      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };\\n\\n      var differenceX = currentOffset.pageX - startOffset.pageX;\\n      var differenceY = currentOffset.pageY - startOffset.pageY;\\n\\n      applyTouchMove(differenceX, differenceY);\\n      startOffset = currentOffset;\\n\\n      var currentTime = new Date().getTime();\\n\\n      var timeGap = currentTime - startTime;\\n      if (timeGap > 0) {\\n        speed.x = differenceX / timeGap;\\n        speed.y = differenceY / timeGap;\\n        startTime = currentTime;\\n      }\\n\\n      var ref = shouldStopOrPrevent(differenceX, differenceY);\\n      var stop = ref.stop;\\n      var prevent = ref.prevent;\\n      if (stop) { e.stopPropagation(); }\\n      if (prevent) { e.preventDefault(); }\\n    }\\n  }\\n  function touchEnd() {\\n    if (!inGlobalTouch && inLocalTouch) {\\n      inLocalTouch = false;\\n\\n      if (i.settings.swipeEasing) {\\n        clearInterval(easingLoop);\\n        easingLoop = setInterval(function() {\\n          if (i.isInitialized) {\\n            clearInterval(easingLoop);\\n            return;\\n          }\\n\\n          if (!speed.x && !speed.y) {\\n            clearInterval(easingLoop);\\n            return;\\n          }\\n\\n          if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {\\n            clearInterval(easingLoop);\\n            return;\\n          }\\n\\n          applyTouchMove(speed.x * 30, speed.y * 30);\\n\\n          speed.x *= 0.8;\\n          speed.y *= 0.8;\\n        }, 10);\\n      }\\n    }\\n  }\\n\\n  if (env.supportsTouch) {\\n    i.event.bind(window, 'touchstart', globalTouchStart);\\n    i.event.bind(window, 'touchend', globalTouchEnd);\\n    i.event.bind(element, 'touchstart', touchStart);\\n    i.event.bind(element, 'touchmove', touchMove);\\n    i.event.bind(element, 'touchend', touchEnd);\\n  } else if (env.supportsIePointer) {\\n    if (window.PointerEvent) {\\n      i.event.bind(window, 'pointerdown', globalTouchStart);\\n      i.event.bind(window, 'pointerup', globalTouchEnd);\\n      i.event.bind(element, 'pointerdown', touchStart);\\n      i.event.bind(element, 'pointermove', touchMove);\\n      i.event.bind(element, 'pointerup', touchEnd);\\n    } else if (window.MSPointerEvent) {\\n      i.event.bind(window, 'MSPointerDown', globalTouchStart);\\n      i.event.bind(window, 'MSPointerUp', globalTouchEnd);\\n      i.event.bind(element, 'MSPointerDown', touchStart);\\n      i.event.bind(element, 'MSPointerMove', touchMove);\\n      i.event.bind(element, 'MSPointerUp', touchEnd);\\n    }\\n  }\\n};\\n\\nvar defaultSettings = function () { return ({\\n  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],\\n  maxScrollbarLength: null,\\n  minScrollbarLength: null,\\n  scrollingThreshold: 1000,\\n  scrollXMarginOffset: 0,\\n  scrollYMarginOffset: 0,\\n  suppressScrollX: false,\\n  suppressScrollY: false,\\n  swipePropagation: true,\\n  swipeEasing: true,\\n  useBothWheelAxes: false,\\n  wheelPropagation: false,\\n  wheelSpeed: 1,\\n}); };\\n\\nvar handlers = {\\n  'click-rail': clickRail,\\n  'drag-thumb': dragThumb,\\n  keyboard: keyboard,\\n  wheel: wheel,\\n  touch: touch,\\n};\\n\\nvar PerfectScrollbar = function PerfectScrollbar(element, userSettings) {\\n  var this$1 = this;\\n  if ( userSettings === void 0 ) userSettings = {};\\n\\n  if (typeof element === 'string') {\\n    element = document.querySelector(element);\\n  }\\n\\n  if (!element || !element.nodeName) {\\n    throw new Error('no element is specified to initialize PerfectScrollbar');\\n  }\\n\\n  this.element = element;\\n\\n  element.classList.add(cls.main);\\n\\n  this.settings = defaultSettings();\\n  for (var key in userSettings) {\\n    this$1.settings[key] = userSettings[key];\\n  }\\n\\n  this.containerWidth = null;\\n  this.containerHeight = null;\\n  this.contentWidth = null;\\n  this.contentHeight = null;\\n\\n  var focus = function () { return element.classList.add(cls.state.focus); };\\n  var blur = function () { return element.classList.remove(cls.state.focus); };\\n\\n  this.isRtl = get(element).direction === 'rtl';\\n  this.isNegativeScroll = (function () {\\n    var originalScrollLeft = element.scrollLeft;\\n    var result = null;\\n    element.scrollLeft = -1;\\n    result = element.scrollLeft < 0;\\n    element.scrollLeft = originalScrollLeft;\\n    return result;\\n  })();\\n  this.negativeScrollAdjustment = this.isNegativeScroll\\n    ? element.scrollWidth - element.clientWidth\\n    : 0;\\n  this.event = new EventManager();\\n  this.ownerDocument = element.ownerDocument || document;\\n\\n  this.scrollbarXRail = div(cls.element.rail('x'));\\n  element.appendChild(this.scrollbarXRail);\\n  this.scrollbarX = div(cls.element.thumb('x'));\\n  this.scrollbarXRail.appendChild(this.scrollbarX);\\n  this.scrollbarX.setAttribute('tabindex', 0);\\n  this.event.bind(this.scrollbarX, 'focus', focus);\\n  this.event.bind(this.scrollbarX, 'blur', blur);\\n  this.scrollbarXActive = null;\\n  this.scrollbarXWidth = null;\\n  this.scrollbarXLeft = null;\\n  var railXStyle = get(this.scrollbarXRail);\\n  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);\\n  if (isNaN(this.scrollbarXBottom)) {\\n    this.isScrollbarXUsingBottom = false;\\n    this.scrollbarXTop = toInt(railXStyle.top);\\n  } else {\\n    this.isScrollbarXUsingBottom = true;\\n  }\\n  this.railBorderXWidth =\\n    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);\\n  // Set rail to display:block to calculate margins\\n  set(this.scrollbarXRail, { display: 'block' });\\n  this.railXMarginWidth =\\n    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);\\n  set(this.scrollbarXRail, { display: '' });\\n  this.railXWidth = null;\\n  this.railXRatio = null;\\n\\n  this.scrollbarYRail = div(cls.element.rail('y'));\\n  element.appendChild(this.scrollbarYRail);\\n  this.scrollbarY = div(cls.element.thumb('y'));\\n  this.scrollbarYRail.appendChild(this.scrollbarY);\\n  this.scrollbarY.setAttribute('tabindex', 0);\\n  this.event.bind(this.scrollbarY, 'focus', focus);\\n  this.event.bind(this.scrollbarY, 'blur', blur);\\n  this.scrollbarYActive = null;\\n  this.scrollbarYHeight = null;\\n  this.scrollbarYTop = null;\\n  var railYStyle = get(this.scrollbarYRail);\\n  this.scrollbarYRight = parseInt(railYStyle.right, 10);\\n  if (isNaN(this.scrollbarYRight)) {\\n    this.isScrollbarYUsingRight = false;\\n    this.scrollbarYLeft = toInt(railYStyle.left);\\n  } else {\\n    this.isScrollbarYUsingRight = true;\\n  }\\n  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;\\n  this.railBorderYWidth =\\n    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);\\n  set(this.scrollbarYRail, { display: 'block' });\\n  this.railYMarginHeight =\\n    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);\\n  set(this.scrollbarYRail, { display: '' });\\n  this.railYHeight = null;\\n  this.railYRatio = null;\\n\\n  this.reach = {\\n    x:\\n      element.scrollLeft <= 0\\n        ? 'start'\\n        : element.scrollLeft >= this.contentWidth - this.containerWidth\\n          ? 'end'\\n          : null,\\n    y:\\n      element.scrollTop <= 0\\n        ? 'start'\\n        : element.scrollTop >= this.contentHeight - this.containerHeight\\n          ? 'end'\\n          : null,\\n  };\\n\\n  this.isAlive = true;\\n\\n  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });\\n\\n  this.lastScrollTop = element.scrollTop; // for onScroll only\\n  this.lastScrollLeft = element.scrollLeft; // for onScroll only\\n  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });\\n  updateGeometry(this);\\n};\\n\\nPerfectScrollbar.prototype.update = function update () {\\n  if (!this.isAlive) {\\n    return;\\n  }\\n\\n  // Recalcuate negative scrollLeft adjustment\\n  this.negativeScrollAdjustment = this.isNegativeScroll\\n    ? this.element.scrollWidth - this.element.clientWidth\\n    : 0;\\n\\n  // Recalculate rail margins\\n  set(this.scrollbarXRail, { display: 'block' });\\n  set(this.scrollbarYRail, { display: 'block' });\\n  this.railXMarginWidth =\\n    toInt(get(this.scrollbarXRail).marginLeft) +\\n    toInt(get(this.scrollbarXRail).marginRight);\\n  this.railYMarginHeight =\\n    toInt(get(this.scrollbarYRail).marginTop) +\\n    toInt(get(this.scrollbarYRail).marginBottom);\\n\\n  // Hide scrollbars not to affect scrollWidth and scrollHeight\\n  set(this.scrollbarXRail, { display: 'none' });\\n  set(this.scrollbarYRail, { display: 'none' });\\n\\n  updateGeometry(this);\\n\\n  processScrollDiff(this, 'top', 0, false, true);\\n  processScrollDiff(this, 'left', 0, false, true);\\n\\n  set(this.scrollbarXRail, { display: '' });\\n  set(this.scrollbarYRail, { display: '' });\\n};\\n\\nPerfectScrollbar.prototype.onScroll = function onScroll (e) {\\n  if (!this.isAlive) {\\n    return;\\n  }\\n\\n  updateGeometry(this);\\n  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);\\n  processScrollDiff(\\n    this,\\n    'left',\\n    this.element.scrollLeft - this.lastScrollLeft\\n  );\\n\\n  this.lastScrollTop = this.element.scrollTop;\\n  this.lastScrollLeft = this.element.scrollLeft;\\n};\\n\\nPerfectScrollbar.prototype.destroy = function destroy () {\\n  if (!this.isAlive) {\\n    return;\\n  }\\n\\n  this.event.unbindAll();\\n  remove(this.scrollbarX);\\n  remove(this.scrollbarY);\\n  remove(this.scrollbarXRail);\\n  remove(this.scrollbarYRail);\\n  this.removePsClasses();\\n\\n  // unset elements\\n  this.element = null;\\n  this.scrollbarX = null;\\n  this.scrollbarY = null;\\n  this.scrollbarXRail = null;\\n  this.scrollbarYRail = null;\\n\\n  this.isAlive = false;\\n};\\n\\nPerfectScrollbar.prototype.removePsClasses = function removePsClasses () {\\n  this.element.className = this.element.className\\n    .split(' ')\\n    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })\\n    .join(' ');\\n};\\n\\nexport default PerfectScrollbar;\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js\n// module id = 8\n// module chunks = 0 1","module.exports = \"/**\\r\\n * A collection of shims that provide minimal functionality of the ES6 collections.\\r\\n *\\r\\n * These implementations are not meant to be used outside of the ResizeObserver\\r\\n * modules as they cover only a limited range of use cases.\\r\\n */\\r\\n/* eslint-disable require-jsdoc, valid-jsdoc */\\r\\nvar MapShim = (function () {\\r\\n    if (typeof Map != 'undefined') {\\r\\n        return Map;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns index in provided array that matches the specified key.\\r\\n     *\\r\\n     * @param {Array<Array>} arr\\r\\n     * @param {*} key\\r\\n     * @returns {number}\\r\\n     */\\r\\n    function getIndex(arr, key) {\\r\\n        var result = -1;\\r\\n\\r\\n        arr.some(function (entry, index) {\\r\\n            if (entry[0] === key) {\\r\\n                result = index;\\r\\n\\r\\n                return true;\\r\\n            }\\r\\n\\r\\n            return false;\\r\\n        });\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    return (function () {\\r\\n        function anonymous() {\\r\\n            this.__entries__ = [];\\r\\n        }\\r\\n\\r\\n        var prototypeAccessors = { size: {} };\\r\\n\\r\\n        /**\\r\\n         * @returns {boolean}\\r\\n         */\\r\\n        prototypeAccessors.size.get = function () {\\r\\n            return this.__entries__.length;\\r\\n        };\\r\\n\\r\\n        /**\\r\\n         * @param {*} key\\r\\n         * @returns {*}\\r\\n         */\\r\\n        anonymous.prototype.get = function (key) {\\r\\n            var index = getIndex(this.__entries__, key);\\r\\n            var entry = this.__entries__[index];\\r\\n\\r\\n            return entry && entry[1];\\r\\n        };\\r\\n\\r\\n        /**\\r\\n         * @param {*} key\\r\\n         * @param {*} value\\r\\n         * @returns {void}\\r\\n         */\\r\\n        anonymous.prototype.set = function (key, value) {\\r\\n            var index = getIndex(this.__entries__, key);\\r\\n\\r\\n            if (~index) {\\r\\n                this.__entries__[index][1] = value;\\r\\n            } else {\\r\\n                this.__entries__.push([key, value]);\\r\\n            }\\r\\n        };\\r\\n\\r\\n        /**\\r\\n         * @param {*} key\\r\\n         * @returns {void}\\r\\n         */\\r\\n        anonymous.prototype.delete = function (key) {\\r\\n            var entries = this.__entries__;\\r\\n            var index = getIndex(entries, key);\\r\\n\\r\\n            if (~index) {\\r\\n                entries.splice(index, 1);\\r\\n            }\\r\\n        };\\r\\n\\r\\n        /**\\r\\n         * @param {*} key\\r\\n         * @returns {void}\\r\\n         */\\r\\n        anonymous.prototype.has = function (key) {\\r\\n            return !!~getIndex(this.__entries__, key);\\r\\n        };\\r\\n\\r\\n        /**\\r\\n         * @returns {void}\\r\\n         */\\r\\n        anonymous.prototype.clear = function () {\\r\\n            this.__entries__.splice(0);\\r\\n        };\\r\\n\\r\\n        /**\\r\\n         * @param {Function} callback\\r\\n         * @param {*} [ctx=null]\\r\\n         * @returns {void}\\r\\n         */\\r\\n        anonymous.prototype.forEach = function (callback, ctx) {\\r\\n            if ( ctx === void 0 ) ctx = null;\\r\\n\\r\\n            for (var i = 0, list = this.__entries__; i < list.length; i += 1) {\\r\\n                var entry = list[i];\\r\\n\\r\\n                callback.call(ctx, entry[1], entry[0]);\\r\\n            }\\r\\n        };\\r\\n\\r\\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\\r\\n\\r\\n        return anonymous;\\r\\n    }());\\r\\n})();\\r\\n\\r\\n/**\\r\\n * Detects whether window and document objects are available in current environment.\\r\\n */\\r\\nvar isBrowser = typeof window != 'undefined' && typeof document != 'undefined' && window.document === document;\\r\\n\\r\\n/**\\r\\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\\r\\n * first one is not supported.\\r\\n *\\r\\n * @returns {number} Requests' identifier.\\r\\n */\\r\\nvar requestAnimationFrame$1 = (function () {\\r\\n    if (typeof requestAnimationFrame === 'function') {\\r\\n        return requestAnimationFrame;\\r\\n    }\\r\\n\\r\\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\\r\\n})();\\r\\n\\r\\n// Defines minimum timeout before adding a trailing call.\\r\\nvar trailingTimeout = 2;\\r\\n\\r\\n/**\\r\\n * Creates a wrapper function which ensures that provided callback will be\\r\\n * invoked only once during the specified delay period.\\r\\n *\\r\\n * @param {Function} callback - Function to be invoked after the delay period.\\r\\n * @param {number} delay - Delay after which to invoke callback.\\r\\n * @returns {Function}\\r\\n */\\r\\nvar throttle = function (callback, delay) {\\r\\n    var leadingCall = false,\\r\\n        trailingCall = false,\\r\\n        lastCallTime = 0;\\r\\n\\r\\n    /**\\r\\n     * Invokes the original callback function and schedules new invocation if\\r\\n     * the \\\"proxy\\\" was called during current request.\\r\\n     *\\r\\n     * @returns {void}\\r\\n     */\\r\\n    function resolvePending() {\\r\\n        if (leadingCall) {\\r\\n            leadingCall = false;\\r\\n\\r\\n            callback();\\r\\n        }\\r\\n\\r\\n        if (trailingCall) {\\r\\n            proxy();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Callback invoked after the specified delay. It will further postpone\\r\\n     * invocation of the original function delegating it to the\\r\\n     * requestAnimationFrame.\\r\\n     *\\r\\n     * @returns {void}\\r\\n     */\\r\\n    function timeoutCallback() {\\r\\n        requestAnimationFrame$1(resolvePending);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Schedules invocation of the original function.\\r\\n     *\\r\\n     * @returns {void}\\r\\n     */\\r\\n    function proxy() {\\r\\n        var timeStamp = Date.now();\\r\\n\\r\\n        if (leadingCall) {\\r\\n            // Reject immediately following calls.\\r\\n            if (timeStamp - lastCallTime < trailingTimeout) {\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // Schedule new call to be in invoked when the pending one is resolved.\\r\\n            // This is important for \\\"transitions\\\" which never actually start\\r\\n            // immediately so there is a chance that we might miss one if change\\r\\n            // happens amids the pending invocation.\\r\\n            trailingCall = true;\\r\\n        } else {\\r\\n            leadingCall = true;\\r\\n            trailingCall = false;\\r\\n\\r\\n            setTimeout(timeoutCallback, delay);\\r\\n        }\\r\\n\\r\\n        lastCallTime = timeStamp;\\r\\n    }\\r\\n\\r\\n    return proxy;\\r\\n};\\r\\n\\r\\n// Minimum delay before invoking the update of observers.\\r\\nvar REFRESH_DELAY = 20;\\r\\n\\r\\n// A list of substrings of CSS properties used to find transition events that\\r\\n// might affect dimensions of observed elements.\\r\\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\\r\\n\\r\\n// Detect whether running in IE 11 (facepalm).\\r\\nvar isIE11 = typeof navigator != 'undefined' && /Trident\\\\/.*rv:11/.test(navigator.userAgent);\\r\\n\\r\\n// MutationObserver should not be used if running in Internet Explorer 11 as it's\\r\\n// implementation is unreliable. Example: https://jsfiddle.net/x2r3jpuz/2/\\r\\n//\\r\\n// It's a real bummer that there is no other way to check for this issue but to\\r\\n// use the UA information.\\r\\nvar mutationObserverSupported = typeof MutationObserver != 'undefined' && !isIE11;\\r\\n\\r\\n/**\\r\\n * Singleton controller class which handles updates of ResizeObserver instances.\\r\\n */\\r\\nvar ResizeObserverController = function() {\\r\\n    /**\\r\\n     * Indicates whether DOM listeners have been added.\\r\\n     *\\r\\n     * @private {boolean}\\r\\n     */\\r\\n    this.connected_ = false;\\r\\n\\r\\n    /**\\r\\n     * Tells that controller has subscribed for Mutation Events.\\r\\n     *\\r\\n     * @private {boolean}\\r\\n     */\\r\\n    this.mutationEventsAdded_ = false;\\r\\n\\r\\n    /**\\r\\n     * Keeps reference to the instance of MutationObserver.\\r\\n     *\\r\\n     * @private {MutationObserver}\\r\\n     */\\r\\n    this.mutationsObserver_ = null;\\r\\n\\r\\n    /**\\r\\n     * A list of connected observers.\\r\\n     *\\r\\n     * @private {Array<ResizeObserverSPI>}\\r\\n     */\\r\\n    this.observers_ = [];\\r\\n\\r\\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\\r\\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\\r\\n};\\r\\n\\r\\n/**\\r\\n * Adds observer to observers list.\\r\\n *\\r\\n * @param {ResizeObserverSPI} observer - Observer to be added.\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverController.prototype.addObserver = function (observer) {\\r\\n    if (!~this.observers_.indexOf(observer)) {\\r\\n        this.observers_.push(observer);\\r\\n    }\\r\\n\\r\\n    // Add listeners if they haven't been added yet.\\r\\n    if (!this.connected_) {\\r\\n        this.connect_();\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Removes observer from observers list.\\r\\n *\\r\\n * @param {ResizeObserverSPI} observer - Observer to be removed.\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverController.prototype.removeObserver = function (observer) {\\r\\n    var observers = this.observers_;\\r\\n    var index = observers.indexOf(observer);\\r\\n\\r\\n    // Remove observer if it's present in registry.\\r\\n    if (~index) {\\r\\n        observers.splice(index, 1);\\r\\n    }\\r\\n\\r\\n    // Remove listeners if controller has no connected observers.\\r\\n    if (!observers.length && this.connected_) {\\r\\n        this.disconnect_();\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Invokes the update of observers. It will continue running updates insofar\\r\\n * it detects changes.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverController.prototype.refresh = function () {\\r\\n    var changesDetected = this.updateObservers_();\\r\\n\\r\\n    // Continue running updates if changes have been detected as there might\\r\\n    // be future ones caused by CSS transitions.\\r\\n    if (changesDetected) {\\r\\n        this.refresh();\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Updates every observer from observers list and notifies them of queued\\r\\n * entries.\\r\\n *\\r\\n * @private\\r\\n * @returns {boolean} Returns \\\"true\\\" if any observer has detected changes in\\r\\n *  dimensions of it's elements.\\r\\n */\\r\\nResizeObserverController.prototype.updateObservers_ = function () {\\r\\n    // Collect observers that have active observations.\\r\\n    var activeObservers = this.observers_.filter(function (observer) {\\r\\n        return observer.gatherActive(), observer.hasActive();\\r\\n    });\\r\\n\\r\\n    // Deliver notifications in a separate cycle in order to avoid any\\r\\n    // collisions between observers, e.g. when multiple instances of\\r\\n    // ResizeObserver are tracking the same element and the callback of one\\r\\n    // of them changes content dimensions of the observed target. Sometimes\\r\\n    // this may result in notifications being blocked for the rest of observers.\\r\\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\\r\\n\\r\\n    return activeObservers.length > 0;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Initializes DOM listeners.\\r\\n *\\r\\n * @private\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverController.prototype.connect_ = function () {\\r\\n    // Do nothing if running in a non-browser environment or if listeners\\r\\n    // have been already added.\\r\\n    if (!isBrowser || this.connected_) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Subscription to the \\\"Transitionend\\\" event is used as a workaround for\\r\\n    // delayed transitions. This way it's possible to capture at least the\\r\\n    // final state of an element.\\r\\n    document.addEventListener('transitionend', this.onTransitionEnd_);\\r\\n\\r\\n    window.addEventListener('resize', this.refresh);\\r\\n\\r\\n    if (mutationObserverSupported) {\\r\\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\\r\\n\\r\\n        this.mutationsObserver_.observe(document, {\\r\\n            attributes: true,\\r\\n            childList: true,\\r\\n            characterData: true,\\r\\n            subtree: true\\r\\n        });\\r\\n    } else {\\r\\n        document.addEventListener('DOMSubtreeModified', this.refresh);\\r\\n\\r\\n        this.mutationEventsAdded_ = true;\\r\\n    }\\r\\n\\r\\n    this.connected_ = true;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Removes DOM listeners.\\r\\n *\\r\\n * @private\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverController.prototype.disconnect_ = function () {\\r\\n    // Do nothing if running in a non-browser environment or if listeners\\r\\n    // have been already removed.\\r\\n    if (!isBrowser || !this.connected_) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\\r\\n    window.removeEventListener('resize', this.refresh);\\r\\n\\r\\n    if (this.mutationsObserver_) {\\r\\n        this.mutationsObserver_.disconnect();\\r\\n    }\\r\\n\\r\\n    if (this.mutationEventsAdded_) {\\r\\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\\r\\n    }\\r\\n\\r\\n    this.mutationsObserver_ = null;\\r\\n    this.mutationEventsAdded_ = false;\\r\\n    this.connected_ = false;\\r\\n};\\r\\n\\r\\n/**\\r\\n * \\\"Transitionend\\\" event handler.\\r\\n *\\r\\n * @private\\r\\n * @param {TransitionEvent} event\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\\r\\n        var propertyName = ref.propertyName;\\r\\n\\r\\n    // Detect whether transition may affect dimensions of an element.\\r\\n    var isReflowProperty = transitionKeys.some(function (key) {\\r\\n        return !!~propertyName.indexOf(key);\\r\\n    });\\r\\n\\r\\n    if (isReflowProperty) {\\r\\n        this.refresh();\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Returns instance of the ResizeObserverController.\\r\\n *\\r\\n * @returns {ResizeObserverController}\\r\\n */\\r\\nResizeObserverController.getInstance = function () {\\r\\n    if (!this.instance_) {\\r\\n        this.instance_ = new ResizeObserverController();\\r\\n    }\\r\\n\\r\\n    return this.instance_;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Holds reference to the controller's instance.\\r\\n *\\r\\n * @private {ResizeObserverController}\\r\\n */\\r\\nResizeObserverController.instance_ = null;\\r\\n\\r\\n/**\\r\\n * Defines non-writable/enumerable properties of the provided target object.\\r\\n *\\r\\n * @param {Object} target - Object for which to define properties.\\r\\n * @param {Object} props - Properties to be defined.\\r\\n * @returns {Object} Target object.\\r\\n */\\r\\nvar defineConfigurable = (function (target, props) {\\r\\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\\r\\n        var key = list[i];\\r\\n\\r\\n        Object.defineProperty(target, key, {\\r\\n            value: props[key],\\r\\n            enumerable: false,\\r\\n            writable: false,\\r\\n            configurable: true\\r\\n        });\\r\\n    }\\r\\n\\r\\n    return target;\\r\\n});\\r\\n\\r\\n// Placeholder of an empty content rectangle.\\r\\nvar emptyRect = createRectInit(0, 0, 0, 0);\\r\\n\\r\\n/**\\r\\n * Converts provided string to a number.\\r\\n *\\r\\n * @param {number|string} value\\r\\n * @returns {number}\\r\\n */\\r\\nfunction toFloat(value) {\\r\\n    return parseFloat(value) || 0;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Extracts borders size from provided styles.\\r\\n *\\r\\n * @param {CSSStyleDeclaration} styles\\r\\n * @param {...string} positions - Borders positions (top, right, ...)\\r\\n * @returns {number}\\r\\n */\\r\\nfunction getBordersSize(styles) {\\r\\n    var positions = Array.prototype.slice.call(arguments, 1);\\r\\n\\r\\n    return positions.reduce(function (size, position) {\\r\\n        var value = styles['border-' + position + '-width'];\\r\\n\\r\\n        return size + toFloat(value);\\r\\n    }, 0);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Extracts paddings sizes from provided styles.\\r\\n *\\r\\n * @param {CSSStyleDeclaration} styles\\r\\n * @returns {Object} Paddings box.\\r\\n */\\r\\nfunction getPaddings(styles) {\\r\\n    var positions = ['top', 'right', 'bottom', 'left'];\\r\\n    var paddings = {};\\r\\n\\r\\n    for (var i = 0, list = positions; i < list.length; i += 1) {\\r\\n        var position = list[i];\\r\\n\\r\\n        var value = styles['padding-' + position];\\r\\n\\r\\n        paddings[position] = toFloat(value);\\r\\n    }\\r\\n\\r\\n    return paddings;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Calculates content rectangle of provided SVG element.\\r\\n *\\r\\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\\r\\n *      to be calculated.\\r\\n * @returns {DOMRectInit}\\r\\n */\\r\\nfunction getSVGContentRect(target) {\\r\\n    var bbox = target.getBBox();\\r\\n\\r\\n    return createRectInit(0, 0, bbox.width, bbox.height);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Calculates content rectangle of provided HTMLElement.\\r\\n *\\r\\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\\r\\n * @returns {DOMRectInit}\\r\\n */\\r\\nfunction getHTMLElementContentRect(target) {\\r\\n    // Client width & height properties can't be\\r\\n    // used exclusively as they provide rounded values.\\r\\n    var clientWidth = target.clientWidth;\\r\\n    var clientHeight = target.clientHeight;\\r\\n\\r\\n    // By this condition we can catch all non-replaced inline, hidden and\\r\\n    // detached elements. Though elements with width & height properties less\\r\\n    // than 0.5 will be discarded as well.\\r\\n    //\\r\\n    // Without it we would need to implement separate methods for each of\\r\\n    // those cases and it's not possible to perform a precise and performance\\r\\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\\r\\n    // gives wrong results for elements with width & height less than 0.5.\\r\\n    if (!clientWidth && !clientHeight) {\\r\\n        return emptyRect;\\r\\n    }\\r\\n\\r\\n    var styles = getComputedStyle(target);\\r\\n    var paddings = getPaddings(styles);\\r\\n    var horizPad = paddings.left + paddings.right;\\r\\n    var vertPad = paddings.top + paddings.bottom;\\r\\n\\r\\n    // Computed styles of width & height are being used because they are the\\r\\n    // only dimensions available to JS that contain non-rounded values. It could\\r\\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\\r\\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\\r\\n    var width = toFloat(styles.width),\\r\\n        height = toFloat(styles.height);\\r\\n\\r\\n    // Width & height include paddings and borders when the 'border-box' box\\r\\n    // model is applied (except for IE).\\r\\n    if (styles.boxSizing === 'border-box') {\\r\\n        // Following conditions are required to handle Internet Explorer which\\r\\n        // doesn't include paddings and borders to computed CSS dimensions.\\r\\n        //\\r\\n        // We can say that if CSS dimensions + paddings are equal to the \\\"client\\\"\\r\\n        // properties then it's either IE, and thus we don't need to subtract\\r\\n        // anything, or an element merely doesn't have paddings/borders styles.\\r\\n        if (Math.round(width + horizPad) !== clientWidth) {\\r\\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\\r\\n        }\\r\\n\\r\\n        if (Math.round(height + vertPad) !== clientHeight) {\\r\\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Following steps can't be applied to the document's root element as its\\r\\n    // client[Width/Height] properties represent viewport area of the window.\\r\\n    // Besides, it's as well not necessary as the <html> itself neither has\\r\\n    // rendered scroll bars nor it can be clipped.\\r\\n    if (!isDocumentElement(target)) {\\r\\n        // In some browsers (only in Firefox, actually) CSS width & height\\r\\n        // include scroll bars size which can be removed at this step as scroll\\r\\n        // bars are the only difference between rounded dimensions + paddings\\r\\n        // and \\\"client\\\" properties, though that is not always true in Chrome.\\r\\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\\r\\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\\r\\n\\r\\n        // Chrome has a rather weird rounding of \\\"client\\\" properties.\\r\\n        // E.g. for an element with content width of 314.2px it sometimes gives\\r\\n        // the client width of 315px and for the width of 314.7px it may give\\r\\n        // 314px. And it doesn't happen all the time. So just ignore this delta\\r\\n        // as a non-relevant.\\r\\n        if (Math.abs(vertScrollbar) !== 1) {\\r\\n            width -= vertScrollbar;\\r\\n        }\\r\\n\\r\\n        if (Math.abs(horizScrollbar) !== 1) {\\r\\n            height -= horizScrollbar;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return createRectInit(paddings.left, paddings.top, width, height);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Checks whether provided element is an instance of the SVGGraphicsElement.\\r\\n *\\r\\n * @param {Element} target - Element to be checked.\\r\\n * @returns {boolean}\\r\\n */\\r\\nvar isSVGGraphicsElement = (function () {\\r\\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\\r\\n    // interface.\\r\\n    if (typeof SVGGraphicsElement != 'undefined') {\\r\\n        return function (target) { return target instanceof SVGGraphicsElement; };\\r\\n    }\\r\\n\\r\\n    // If it's so, then check that element is at least an instance of the\\r\\n    // SVGElement and that it has the \\\"getBBox\\\" method.\\r\\n    // eslint-disable-next-line no-extra-parens\\r\\n    return function (target) { return target instanceof SVGElement && typeof target.getBBox === 'function'; };\\r\\n})();\\r\\n\\r\\n/**\\r\\n * Checks whether provided element is a document element (<html>).\\r\\n *\\r\\n * @param {Element} target - Element to be checked.\\r\\n * @returns {boolean}\\r\\n */\\r\\nfunction isDocumentElement(target) {\\r\\n    return target === document.documentElement;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Calculates an appropriate content rectangle for provided html or svg element.\\r\\n *\\r\\n * @param {Element} target - Element content rectangle of which needs to be calculated.\\r\\n * @returns {DOMRectInit}\\r\\n */\\r\\nfunction getContentRect(target) {\\r\\n    if (!isBrowser) {\\r\\n        return emptyRect;\\r\\n    }\\r\\n\\r\\n    if (isSVGGraphicsElement(target)) {\\r\\n        return getSVGContentRect(target);\\r\\n    }\\r\\n\\r\\n    return getHTMLElementContentRect(target);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates rectangle with an interface of the DOMRectReadOnly.\\r\\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\\r\\n *\\r\\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\\r\\n * @returns {DOMRectReadOnly}\\r\\n */\\r\\nfunction createReadOnlyRect(ref) {\\r\\n    var x = ref.x;\\r\\n    var y = ref.y;\\r\\n    var width = ref.width;\\r\\n    var height = ref.height;\\r\\n\\r\\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\\r\\n    var Constr = typeof DOMRectReadOnly != 'undefined' ? DOMRectReadOnly : Object;\\r\\n    var rect = Object.create(Constr.prototype);\\r\\n\\r\\n    // Rectangle's properties are not writable and non-enumerable.\\r\\n    defineConfigurable(rect, {\\r\\n        x: x, y: y, width: width, height: height,\\r\\n        top: y,\\r\\n        right: x + width,\\r\\n        bottom: height + y,\\r\\n        left: x\\r\\n    });\\r\\n\\r\\n    return rect;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\\r\\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\\r\\n *\\r\\n * @param {number} x - X coordinate.\\r\\n * @param {number} y - Y coordinate.\\r\\n * @param {number} width - Rectangle's width.\\r\\n * @param {number} height - Rectangle's height.\\r\\n * @returns {DOMRectInit}\\r\\n */\\r\\nfunction createRectInit(x, y, width, height) {\\r\\n    return { x: x, y: y, width: width, height: height };\\r\\n}\\r\\n\\r\\n/**\\r\\n * Class that is responsible for computations of the content rectangle of\\r\\n * provided DOM element and for keeping track of it's changes.\\r\\n */\\r\\nvar ResizeObservation = function(target) {\\r\\n    /**\\r\\n     * Broadcasted width of content rectangle.\\r\\n     *\\r\\n     * @type {number}\\r\\n     */\\r\\n    this.broadcastWidth = 0;\\r\\n\\r\\n    /**\\r\\n     * Broadcasted height of content rectangle.\\r\\n     *\\r\\n     * @type {number}\\r\\n     */\\r\\n    this.broadcastHeight = 0;\\r\\n\\r\\n    /**\\r\\n     * Reference to the last observed content rectangle.\\r\\n     *\\r\\n     * @private {DOMRectInit}\\r\\n     */\\r\\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\\r\\n\\r\\n    /**\\r\\n     * Reference to the observed element.\\r\\n     *\\r\\n     * @type {Element}\\r\\n     */\\r\\n    this.target = target;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Updates content rectangle and tells whether it's width or height properties\\r\\n * have changed since the last broadcast.\\r\\n *\\r\\n * @returns {boolean}\\r\\n */\\r\\nResizeObservation.prototype.isActive = function () {\\r\\n    var rect = getContentRect(this.target);\\r\\n\\r\\n    this.contentRect_ = rect;\\r\\n\\r\\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\\r\\n * from the corresponding properties of the last observed content rectangle.\\r\\n *\\r\\n * @returns {DOMRectInit} Last observed content rectangle.\\r\\n */\\r\\nResizeObservation.prototype.broadcastRect = function () {\\r\\n    var rect = this.contentRect_;\\r\\n\\r\\n    this.broadcastWidth = rect.width;\\r\\n    this.broadcastHeight = rect.height;\\r\\n\\r\\n    return rect;\\r\\n};\\r\\n\\r\\nvar ResizeObserverEntry = function(target, rectInit) {\\r\\n    var contentRect = createReadOnlyRect(rectInit);\\r\\n\\r\\n    // According to the specification following properties are not writable\\r\\n    // and are also not enumerable in the native implementation.\\r\\n    //\\r\\n    // Property accessors are not being used as they'd require to define a\\r\\n    // private WeakMap storage which may cause memory leaks in browsers that\\r\\n    // don't support this type of collections.\\r\\n    defineConfigurable(this, { target: target, contentRect: contentRect });\\r\\n};\\r\\n\\r\\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\\r\\n    if (typeof callback !== 'function') {\\r\\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Collection of resize observations that have detected changes in dimensions\\r\\n     * of elements.\\r\\n     *\\r\\n     * @private {Array<ResizeObservation>}\\r\\n     */\\r\\n    this.activeObservations_ = [];\\r\\n\\r\\n    /**\\r\\n     * Registry of the ResizeObservation instances.\\r\\n     *\\r\\n     * @private {Map<Element, ResizeObservation>}\\r\\n     */\\r\\n    this.observations_ = new MapShim();\\r\\n\\r\\n    /**\\r\\n     * Reference to the callback function.\\r\\n     *\\r\\n     * @private {ResizeObserverCallback}\\r\\n     */\\r\\n    this.callback_ = callback;\\r\\n\\r\\n    /**\\r\\n     * Reference to the associated ResizeObserverController.\\r\\n     *\\r\\n     * @private {ResizeObserverController}\\r\\n     */\\r\\n    this.controller_ = controller;\\r\\n\\r\\n    /**\\r\\n     * Public ResizeObserver instance which will be passed to the callback\\r\\n     * function and used as a value of it's \\\"this\\\" binding.\\r\\n     *\\r\\n     * @private {ResizeObserver}\\r\\n     */\\r\\n    this.callbackCtx_ = callbackCtx;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Starts observing provided element.\\r\\n *\\r\\n * @param {Element} target - Element to be observed.\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverSPI.prototype.observe = function (target) {\\r\\n    if (!arguments.length) {\\r\\n        throw new TypeError('1 argument required, but only 0 present.');\\r\\n    }\\r\\n\\r\\n    // Do nothing if current environment doesn't have the Element interface.\\r\\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if (!(target instanceof Element)) {\\r\\n        throw new TypeError('parameter 1 is not of type \\\"Element\\\".');\\r\\n    }\\r\\n\\r\\n    var observations = this.observations_;\\r\\n\\r\\n    // Do nothing if element is already being observed.\\r\\n    if (observations.has(target)) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    observations.set(target, new ResizeObservation(target));\\r\\n\\r\\n    this.controller_.addObserver(this);\\r\\n\\r\\n    // Force the update of observations.\\r\\n    this.controller_.refresh();\\r\\n};\\r\\n\\r\\n/**\\r\\n * Stops observing provided element.\\r\\n *\\r\\n * @param {Element} target - Element to stop observing.\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverSPI.prototype.unobserve = function (target) {\\r\\n    if (!arguments.length) {\\r\\n        throw new TypeError('1 argument required, but only 0 present.');\\r\\n    }\\r\\n\\r\\n    // Do nothing if current environment doesn't have the Element interface.\\r\\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if (!(target instanceof Element)) {\\r\\n        throw new TypeError('parameter 1 is not of type \\\"Element\\\".');\\r\\n    }\\r\\n\\r\\n    var observations = this.observations_;\\r\\n\\r\\n    // Do nothing if element is not being observed.\\r\\n    if (!observations.has(target)) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    observations.delete(target);\\r\\n\\r\\n    if (!observations.size) {\\r\\n        this.controller_.removeObserver(this);\\r\\n    }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Stops observing all elements.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverSPI.prototype.disconnect = function () {\\r\\n    this.clearActive();\\r\\n    this.observations_.clear();\\r\\n    this.controller_.removeObserver(this);\\r\\n};\\r\\n\\r\\n/**\\r\\n * Collects observation instances the associated element of which has changed\\r\\n * it's content rectangle.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverSPI.prototype.gatherActive = function () {\\r\\n        var this$1 = this;\\r\\n\\r\\n    this.clearActive();\\r\\n\\r\\n    this.observations_.forEach(function (observation) {\\r\\n        if (observation.isActive()) {\\r\\n            this$1.activeObservations_.push(observation);\\r\\n        }\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * Invokes initial callback function with a list of ResizeObserverEntry\\r\\n * instances collected from active resize observations.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverSPI.prototype.broadcastActive = function () {\\r\\n    // Do nothing if observer doesn't have active observations.\\r\\n    if (!this.hasActive()) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    var ctx = this.callbackCtx_;\\r\\n\\r\\n    // Create ResizeObserverEntry instance for every active observation.\\r\\n    var entries = this.activeObservations_.map(function (observation) {\\r\\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\\r\\n    });\\r\\n\\r\\n    this.callback_.call(ctx, entries, ctx);\\r\\n    this.clearActive();\\r\\n};\\r\\n\\r\\n/**\\r\\n * Clears the collection of active observations.\\r\\n *\\r\\n * @returns {void}\\r\\n */\\r\\nResizeObserverSPI.prototype.clearActive = function () {\\r\\n    this.activeObservations_.splice(0);\\r\\n};\\r\\n\\r\\n/**\\r\\n * Tells whether observer has active observations.\\r\\n *\\r\\n * @returns {boolean}\\r\\n */\\r\\nResizeObserverSPI.prototype.hasActive = function () {\\r\\n    return this.activeObservations_.length > 0;\\r\\n};\\r\\n\\r\\n// Registry of internal observers. If WeakMap is not available use current shim\\r\\n// for the Map collection as it has all required methods and because WeakMap\\r\\n// can't be fully polyfilled anyway.\\r\\nvar observers = typeof WeakMap != 'undefined' ? new WeakMap() : new MapShim();\\r\\n\\r\\n/**\\r\\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\\r\\n * exposing only those methods and properties that are defined in the spec.\\r\\n */\\r\\nvar ResizeObserver$1 = function(callback) {\\r\\n    if (!(this instanceof ResizeObserver$1)) {\\r\\n        throw new TypeError('Cannot call a class as a function');\\r\\n    }\\r\\n\\r\\n    if (!arguments.length) {\\r\\n        throw new TypeError('1 argument required, but only 0 present.');\\r\\n    }\\r\\n\\r\\n    var controller = ResizeObserverController.getInstance();\\r\\n    var observer = new ResizeObserverSPI(callback, controller, this);\\r\\n\\r\\n    observers.set(this, observer);\\r\\n};\\r\\n\\r\\n// Expose public methods of ResizeObserver.\\r\\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\\r\\n    ResizeObserver$1.prototype[method] = function () {\\r\\n        return (ref = observers.get(this))[method].apply(ref, arguments);\\r\\n        var ref;\\r\\n    };\\r\\n});\\r\\n\\r\\nvar index = (function () {\\r\\n    // Export existing implementation if available.\\r\\n    if (typeof ResizeObserver != 'undefined') {\\r\\n        // eslint-disable-next-line no-undef\\r\\n        return ResizeObserver;\\r\\n    }\\r\\n\\r\\n    return ResizeObserver$1;\\r\\n})();\\r\\n\\r\\nexport default index;\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n// module id = 9\n// module chunks = 0 1","module.exports = \"<div #ps=\\\"ngxPerfectScrollbar\\\" [perfectScrollbar]=\\\"getConfig()\\\" [hidden]=\\\"hidden\\\" [fxHide]=\\\"fxHide\\\" [fxShow]=\\\"fxShow\\\" [disabled]=\\\"disabled\\\" [usePSClass]=\\\"usePSClass\\\" [psPosStyle]=\\\"null\\\" [runInsideAngular]=\\\"runInsideAngular\\\" (wheel)=\\\"onWheelEvent($event)\\\" (touchstart)=\\\"onTouchStart($event)\\\" (touchmove)=\\\"onTouchMove($event)\\\" (touchend)=\\\"onTouchEnd($event)\\\" (ps-scroll-x)=\\\"onScrollEvent($event, 'x')\\\"  (ps-scroll-y)=\\\"onScrollEvent($event, 'y')\\\" (ps-x-reach-end)=\\\"onScrollEvent($event, 'right')\\\" (ps-y-reach-end)=\\\"onScrollEvent($event, 'bottom')\\\" (ps-x-reach-start)=\\\"onScrollEvent($event, 'left')\\\" (ps-y-reach-start)=\\\"onScrollEvent($event, 'top')\\\" (psScrollY)=\\\"PS_SCROLL_Y.emit($event)\\\" (psScrollX)=\\\"PS_SCROLL_X.emit($event)\\\" (psScrollUp)=\\\"PS_SCROLL_UP.emit($event)\\\" (psScrollDown)=\\\"PS_SCROLL_DOWN.emit($event)\\\" (psScrollLeft)=\\\"PS_SCROLL_LEFT.emit($event)\\\" (psScrollRight)=\\\"PS_SCROLL_RIGHT.emit($event)\\\" (psYReachEnd)=\\\"PS_Y_REACH_END.emit($event)\\\" (psYReachStart)=\\\"PS_Y_REACH_START.emit($event)\\\" (psXReachEnd)=\\\"PS_X_REACH_END.emit($event)\\\" (psXReachStart)=\\\"PS_X_REACH_START.emit($event)\\\">\\n  <div class=\\\"ps-content\\\">\\n    <ng-content></ng-content>\\n  </div>\\n\\n  <div *ngIf=\\\"autoPropagation || scrollIndicators\\\" class=\\\"ps-overlay\\\" [class.ps-at-top]=\\\"states.top\\\" [class.ps-at-left]=\\\"states.left\\\" [class.ps-at-right]=\\\"states.right\\\" [class.ps-at-bottom]=\\\"states.bottom\\\">\\n    <div class=\\\"ps-indicator-top\\\" [class.ps-notify]=\\\"notify && userInteraction\\\"></div>\\n    <div class=\\\"ps-indicator-left\\\" [class.ps-notify]=\\\"notify && userInteraction\\\"></div>\\n    <div class=\\\"ps-indicator-right\\\" [class.ps-notify]=\\\"notify && userInteraction\\\"></div>\\n    <div class=\\\"ps-indicator-bottom\\\" [class.ps-notify]=\\\"notify && userInteraction\\\"></div>\\n  </div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/perfect-scrollbar.component.html\n// module id = 10\n// module chunks = 0 1","module.exports = \"/*\\n * Container style\\n */\\n.ps {\\n  overflow: hidden !important;\\n  overflow-anchor: none;\\n  -ms-overflow-style: none;\\n  touch-action: auto;\\n  -ms-touch-action: auto; }\\n\\n/*\\n * Scrollbar rail styles\\n */\\n.ps__rail-x {\\n  display: none;\\n  opacity: 0;\\n  transition: background-color .2s linear, opacity .2s linear;\\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\\n  height: 15px;\\n  /* there must be 'bottom' or 'top' for ps__rail-x */\\n  bottom: 0px;\\n  /* please don't change 'position' */\\n  position: absolute; }\\n\\n.ps__rail-y {\\n  display: none;\\n  opacity: 0;\\n  transition: background-color .2s linear, opacity .2s linear;\\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\\n  width: 15px;\\n  /* there must be 'right' or 'left' for ps__rail-y */\\n  right: 0;\\n  /* please don't change 'position' */\\n  position: absolute; }\\n\\n.ps--active-x > .ps__rail-x,\\n.ps--active-y > .ps__rail-y {\\n  display: block;\\n  background-color: transparent; }\\n\\n.ps:hover > .ps__rail-x,\\n.ps:hover > .ps__rail-y,\\n.ps--focus > .ps__rail-x,\\n.ps--focus > .ps__rail-y,\\n.ps--scrolling-x > .ps__rail-x,\\n.ps--scrolling-y > .ps__rail-y {\\n  opacity: 0.6; }\\n\\n.ps__rail-x:hover,\\n.ps__rail-y:hover,\\n.ps__rail-x:focus,\\n.ps__rail-y:focus {\\n  background-color: #eee;\\n  opacity: 0.9; }\\n\\n/*\\n * Scrollbar thumb styles\\n */\\n.ps__thumb-x {\\n  background-color: #aaa;\\n  border-radius: 6px;\\n  transition: background-color .2s linear, height .2s ease-in-out;\\n  -webkit-transition: background-color .2s linear, height .2s ease-in-out;\\n  height: 6px;\\n  /* there must be 'bottom' for ps__thumb-x */\\n  bottom: 2px;\\n  /* please don't change 'position' */\\n  position: absolute; }\\n\\n.ps__thumb-y {\\n  background-color: #aaa;\\n  border-radius: 6px;\\n  transition: background-color .2s linear, width .2s ease-in-out;\\n  -webkit-transition: background-color .2s linear, width .2s ease-in-out;\\n  width: 6px;\\n  /* there must be 'right' for ps__thumb-y */\\n  right: 2px;\\n  /* please don't change 'position' */\\n  position: absolute; }\\n\\n.ps__rail-x:hover > .ps__thumb-x,\\n.ps__rail-x:focus > .ps__thumb-x {\\n  background-color: #999;\\n  height: 11px; }\\n\\n.ps__rail-y:hover > .ps__thumb-y,\\n.ps__rail-y:focus > .ps__thumb-y {\\n  background-color: #999;\\n  width: 11px; }\\n\\n/* MS supports */\\n@supports (-ms-overflow-style: none) {\\n  .ps {\\n    overflow: auto !important; } }\\n\\n@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {\\n  .ps {\\n    overflow: auto !important; } }\\n\\n/*\\n  TODO: Remove important flags after this bug if fixed:\\n  https://github.com/angular/flex-layout/issues/381\\n*/\\nperfect-scrollbar {\\n  position: relative;\\n  display: block;\\n  width: 100%;\\n  height: 100%;\\n  max-width: 100%;\\n  max-height: 100%;\\n  /* stylelint-disable */\\n  /* stylelint-enable */ }\\n  perfect-scrollbar[hidden] {\\n    display: none; }\\n  perfect-scrollbar[fxflex] {\\n    display: flex;\\n    flex-direction: column;\\n    -webkit-box-orient: column;\\n    -webkit-box-direction: column;\\n    height: auto;\\n    min-width: 0;\\n    min-height: 0; }\\n    perfect-scrollbar[fxflex] > .ps {\\n      flex: 1 1 auto;\\n      -ms-flex: 1 1 auto;\\n      -webkit-box-flex: 1;\\n      width: auto;\\n      height: auto;\\n      min-width: 0;\\n      min-height: 0; }\\n  perfect-scrollbar[fxlayout] {\\n    display: flex;\\n    flex-direction: inherit;\\n    -webkit-box-orient: inherit;\\n    -webkit-box-direction: inherit;\\n    align-item: inherit;\\n    place-content: inherit;\\n    -webkit-box-pack: inherit;\\n    -webkit-box-align: inherit; }\\n    perfect-scrollbar[fxlayout] > .ps,\\n    perfect-scrollbar[fxlayout] > .ps > .ps-content {\\n      display: flex;\\n      flex-direction: inherit !important;\\n      -webkit-box-orient: inherit !important;\\n      -webkit-box-direction: inherit !important;\\n      align-item: inherit;\\n      place-content: inherit;\\n      -webkit-box-pack: inherit;\\n      -webkit-box-align: inherit; }\\n  perfect-scrollbar > .ps {\\n    position: static;\\n    display: block;\\n    width: inherit;\\n    height: inherit;\\n    max-width: inherit;\\n    max-height: inherit; }\\n    perfect-scrollbar > .ps > .ps-overlay {\\n      position: absolute;\\n      top: 0;\\n      right: 0;\\n      bottom: 0;\\n      left: 0;\\n      display: block;\\n      overflow: hidden;\\n      pointer-events: none; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-top,\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-left,\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-right,\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-bottom {\\n        position: absolute;\\n        opacity: 0;\\n        transition: opacity 300ms ease-in-out; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-top,\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-bottom {\\n        left: 0;\\n        min-width: 100%;\\n        min-height: 24px; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-left,\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-right {\\n        top: 0;\\n        min-width: 24px;\\n        min-height: 100%; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-top {\\n        top: 0; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-left {\\n        left: 0; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-right {\\n        right: 0; }\\n      perfect-scrollbar > .ps > .ps-overlay .ps-indicator-bottom {\\n        bottom: 0; }\\n    perfect-scrollbar > .ps.ps--active-y > .ps__rail-y {\\n      width: 10px;\\n      top: 0 !important;\\n      right: 0 !important;\\n      transition: width 200ms linear, opacity 200ms linear, background-color 200ms linear; }\\n      perfect-scrollbar > .ps.ps--active-y > .ps__rail-y:hover {\\n        width: 15px; }\\n    perfect-scrollbar > .ps.ps--active-x > .ps__rail-x {\\n      height: 10px;\\n      bottom: 0 !important;\\n      left: 0 !important;\\n      transition: height 200ms linear, opacity 200ms linear, background-color 200ms linear; }\\n      perfect-scrollbar > .ps.ps--active-x > .ps__rail-x:hover {\\n        height: 15px; }\\n    perfect-scrollbar > .ps.ps--active-x.ps--active-y > .ps__rail-y {\\n      margin: 0 0 10px; }\\n    perfect-scrollbar > .ps.ps--active-x.ps--active-y > .ps__rail-x {\\n      margin: 0 10px 0 0; }\\n    perfect-scrollbar > .ps.ps--scrolling-y > .ps__rail-y {\\n      opacity: 0.9;\\n      background-color: #eee; }\\n    perfect-scrollbar > .ps.ps--scrolling-x > .ps__rail-x {\\n      opacity: 0.9;\\n      background-color: #eee; }\\n  perfect-scrollbar.ps-spacing-tn, perfect-scrollbar.ps-spacing-xs, perfect-scrollbar.ps-spacing-sm {\\n    padding: 0 12px 12px 0;\\n    margin: 0 -12px -12px 0; }\\n    perfect-scrollbar.ps-spacing-tn > .ps > .ps-overlay, perfect-scrollbar.ps-spacing-xs > .ps > .ps-overlay, perfect-scrollbar.ps-spacing-sm > .ps > .ps-overlay {\\n      right: 12px;\\n      bottom: 12px; }\\n  perfect-scrollbar.ps-spacing-md, perfect-scrollbar.ps-spacing-lg, perfect-scrollbar.ps-spacing-xl {\\n    padding: 0 24px 24px 0;\\n    margin: 0 -24px -24px 0; }\\n    perfect-scrollbar.ps-spacing-md > .ps > .ps-overlay, perfect-scrollbar.ps-spacing-lg > .ps > .ps-overlay, perfect-scrollbar.ps-spacing-xl > .ps > .ps-overlay {\\n      right: 24px;\\n      bottom: 24px; }\\n  perfect-scrollbar.ps-show-always > .ps.ps--active-y > .ps__rail-y {\\n    opacity: 0.6; }\\n  perfect-scrollbar.ps-show-always > .ps.ps--active-x > .ps__rail-x {\\n    opacity: 0.6; }\\n  perfect-scrollbar.ps-show-active > .ps.ps--active-y > .ps-overlay:not(.ps-at-top) .ps-indicator-top {\\n    opacity: 1;\\n    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0) 100%); }\\n  perfect-scrollbar.ps-show-active > .ps.ps--active-y > .ps-overlay:not(.ps-at-bottom) .ps-indicator-bottom {\\n    opacity: 1;\\n    background: linear-gradient(to top, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0) 100%); }\\n  perfect-scrollbar.ps-show-active > .ps.ps--active-x > .ps-overlay:not(.ps-at-left) .ps-indicator-left {\\n    opacity: 1;\\n    background: linear-gradient(to right, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0) 100%); }\\n  perfect-scrollbar.ps-show-active > .ps.ps--active-x > .ps-overlay:not(.ps-at-right) .ps-indicator-right {\\n    opacity: 1;\\n    background: linear-gradient(to left, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0) 100%); }\\n  perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-y > .ps-overlay.ps-at-top .ps-indicator-top {\\n    background: linear-gradient(to bottom, rgba(170, 170, 170, 0.5) 0%, rgba(170, 170, 170, 0) 100%); }\\n    perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-y > .ps-overlay.ps-at-top .ps-indicator-top.ps-notify {\\n      opacity: 1; }\\n  perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-y > .ps-overlay.ps-at-bottom .ps-indicator-bottom {\\n    background: linear-gradient(to top, rgba(170, 170, 170, 0.5) 0%, rgba(170, 170, 170, 0) 100%); }\\n    perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-y > .ps-overlay.ps-at-bottom .ps-indicator-bottom.ps-notify {\\n      opacity: 1; }\\n  perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-x > .ps-overlay.ps-at-left .ps-indicator-left {\\n    background: linear-gradient(to right, rgba(170, 170, 170, 0.5) 0%, rgba(170, 170, 170, 0) 100%); }\\n    perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-x > .ps-overlay.ps-at-left .ps-indicator-left.ps-notify {\\n      opacity: 1; }\\n  perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-x > .ps-overlay.ps-at-right .ps-indicator-right {\\n    background: linear-gradient(to left, rgba(170, 170, 170, 0.5) 0%, rgba(170, 170, 170, 0) 100%); }\\n    perfect-scrollbar.ps-show-active.ps-show-limits > .ps.ps--active-x > .ps-overlay.ps-at-right .ps-indicator-right.ps-notify {\\n      opacity: 1; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/perfect-scrollbar.component.scss\n// module id = 11\n// module chunks = 0 1","import { CommonModule } from '@angular/common';\n\nimport { NgModule, ModuleWithProviders, OpaqueToken, Optional, SkipSelf, Inject } from '@angular/core';\n\nimport { PerfectScrollbarComponent } from './perfect-scrollbar.component';\nimport { PerfectScrollbarDirective } from './perfect-scrollbar.directive';\n\nimport { PerfectScrollbarConfig, PerfectScrollbarConfigInterface } from './perfect-scrollbar.interfaces';\n\nexport const PERFECT_SCROLLBAR_GUARD = new OpaqueToken('PERFECT_SCROLLBAR_GUARD');\nexport const PERFECT_SCROLLBAR_CONFIG = new OpaqueToken('PERFECT_SCROLLBAR_CONFIG');\n\n@NgModule({\n    imports: [CommonModule],\n    declarations: [PerfectScrollbarComponent, PerfectScrollbarDirective],\n    exports: [CommonModule, PerfectScrollbarComponent, PerfectScrollbarDirective]\n})\nexport class PerfectScrollbarModule {\n  constructor (@Optional() @Inject(PERFECT_SCROLLBAR_GUARD) guard: any) {}\n\n  static forRoot(config?: PerfectScrollbarConfigInterface): ModuleWithProviders {\n    return {\n      ngModule: PerfectScrollbarModule,\n      providers: [\n        {\n          provide: PERFECT_SCROLLBAR_GUARD,\n          useFactory: provideForRootGuard,\n          deps: [\n            [\n              PerfectScrollbarConfig,\n              new Optional(),\n              new SkipSelf()\n            ]\n          ]\n        },\n        {\n          provide: PERFECT_SCROLLBAR_CONFIG,\n          useValue: config ? config : {}\n        },\n        {\n          provide: PerfectScrollbarConfig,\n          useFactory: provideDefaultConfig,\n          deps: [\n            PERFECT_SCROLLBAR_CONFIG\n          ]\n        }\n      ]\n    };\n  }\n\n  static forChild(): ModuleWithProviders {\n    return {\n      ngModule: PerfectScrollbarModule\n    };\n  }\n}\n\nexport function provideForRootGuard(config: PerfectScrollbarConfig): any {\n  if (config) {\n    throw new Error(`\n      Application called PerfectScrollbarModule.forRoot() twice.\n      For submodules use PerfectScrollbarModule.forChild() instead.\n    `);\n  }\n\n  return 'guarded';\n}\n\nexport function provideDefaultConfig(config: PerfectScrollbarConfigInterface): PerfectScrollbarConfig {\n  return new PerfectScrollbarConfig(config);\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/angular2-template-loader!./src/lib/perfect-scrollbar.module.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@angular/common\"\n// module id = 13\n// module chunks = 0 1"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;AC7DA;;;;;;;;;ACAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAbA;AAeA;AAIA;AACA;AACA;AACA;AACA;AAAA;AARA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAyBA;AAsBA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AA/BA;;;;;;;;;;;;;;;;;;;;;;AC/DA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAMA;AA4DA;AAAA;AAAA;AACA;AAAA;AArDA;AACA;AAEA;AAEA;AAGA;AAGA;AAEA;AAWA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAkBA;AAnCA;AAAA;AACA;AAEA;AACA;;;AAAA;AAeA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAMA;AAEA;AAAA;AACA;AACA;AAIA;AAAA;AACA;AAIA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvSA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAGA;AADA;AACA;;AAAA;AAGA;AADA;AACA;;AAAA;AAEA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAGA;AADA;;;AAKA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAIA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AAEA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AAEA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AACA;AAAA;;;;AAAA;AA1DA;AAJA;AACA;AACA;AACA;AA6DA;AAAA;AACA;AA7DA;AAgTA;AAAA;AAhTA;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AASA;AA+DA;AAAA;AAAA;AA9DA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AAGA;AAGA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AAPA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AA7PA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAGA;AADA;AACA;;AAAA;AAEA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAGA;AADA;AACA;;AAAA;AAGA;AADA;AACA;;AAAA;AAEA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;;;;AAKA;AA7DA;AANA;AACA;AACA;AACA;AACA;AACA;AAgEA;AA/DA;AAmRA;AAAA;AAnRA;;;;;;;;;;ACnBA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAIA;AACA;AACA;;;;;;;ACXA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AAAA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AArCA;AALA;AACA;AACA;AACA;AACA;AAEA;;AADA;AAsCA;;AAAA;AAtCA;AAwCA;AACA;AACA;AAIA;AAEA;AACA;AATA;AAWA;AACA;AACA;AAFA;;;;;;;ACpEA;;;;A","sourceRoot":""}